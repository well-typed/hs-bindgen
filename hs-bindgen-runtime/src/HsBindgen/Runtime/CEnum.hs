{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE TypeFamilies #-}

-- | C enumerations
--
-- This module is intended to be imported qualified.
module HsBindgen.Runtime.CEnum (
    -- * Type classes
    CEnum(..)
  , SequentialCEnum(..)
    -- * API
  , getNames
    -- * Instance support
  , showCEnum
  , seqIsDeclared
  , seqMkDeclared
    -- * Deriving via support
  , AsCEnum(..)
  , AsSequentialCEnum(..)
    -- ** Exceptions
  , CEnumException(..)
  ) where

import Control.Exception (Exception(displayException), throw)
import Data.Bifunctor (Bifunctor(first))
import Data.List qualified as List
import Data.List.NonEmpty (NonEmpty((:|)))
import Data.List.NonEmpty qualified as NonEmpty
import Data.Map.Strict (Map)
import Data.Map.Strict qualified as Map
import Data.Proxy (Proxy(Proxy))

{-------------------------------------------------------------------------------
  Type classes
-------------------------------------------------------------------------------}

-- | C enumeration
--
-- This class implements an API for Haskell representations of C enumerations.
-- C @enum@ declarations only declare values; they do not limit the range of the
-- corresponding integral type.  They may have negative values, non-sequential
-- values, and multiple names for a single value.
--
-- At a low level, @hs-bindgen@ generates a @newtype@ wrapper around the
-- integral representation type to represent a C @enum@.  An instance of this
-- class is generated automatically.  A 'Show' instance defined using
-- 'showCEnum' is also generated by default.  'Bounded' and 'Enum' instances are
-- /not/ generated automatically because values do not technically need to be
-- declared.  Users may optionally derive these instances using 'AsCEnum` when
-- appropriate.
--
-- This class may also be used with Haskell sum-type representations of
-- enumerations.
class Integral (CEnumZ a) => CEnum a where
  -- | Integral representation type
  type CEnumZ a

  -- | Construct a value from the integral representation
  --
  -- prop> toCEnumZ . fromCEnumZ === id
  fromCEnumZ :: CEnumZ a -> a

  -- | Get the integral representation for a value
  --
  -- prop> fromCEnumZ . toCEnumZ === id
  toCEnumZ :: a -> CEnumZ a

  -- | Declared values and associated names
  declaredValues :: proxy a -> Map (CEnumZ a) (NonEmpty String)

  -- | Determine if the specified value is declared
  isDeclared :: a -> Bool
  isDeclared x = (toCEnumZ x) `Map.member` declaredValues (Proxy :: Proxy a)

  -- | Construct a value only if it is declared
  mkDeclared :: CEnumZ a -> Maybe a
  mkDeclared i
    | i `Map.member` declaredValues (Proxy :: Proxy a) = Just (fromCEnumZ i)
    | otherwise = Nothing

-- | C enumeration with sequential values
--
-- 'Bounded' and 'Enum' methods may be implemented more efficiently when the
-- values of an enumeration are sequential.  An instance of this class is
-- generated automatically in this case.  Users may optionally derive these
-- instances using 'AsSequentialCEnum' when appropriate.
--
-- This class may also be used with Haskell sum-type representations of
-- enumerations.
--
-- prop> all isDeclared [minDeclaredValue..maxDeclaredValue]
class CEnum a => SequentialCEnum a where
  -- | The minimum declared value
  --
  -- prop> Just minDeclaredValue === fst <$> Map.lookupMin (declaredValues proxy)
  minDeclaredValue :: a

  -- | The maximum declared value
  --
  -- prop> Just maxDeclaredValue === fst <$> Map.lookupMax (declaredValues proxy)
  --
  -- prop> minDeclaredValue <= maxDeclaredValue
  maxDeclaredValue :: a

{-------------------------------------------------------------------------------
  API
-------------------------------------------------------------------------------}

-- | Get all names associated with a value
--
-- An empty list is returned when the specified value is not declared.
getNames :: forall a. CEnum a => a -> [String]
getNames x = maybe [] NonEmpty.toList $
    Map.lookup (toCEnumZ x) (declaredValues (Proxy :: Proxy a))

{-------------------------------------------------------------------------------
  Instance support
-------------------------------------------------------------------------------}

-- | Show the specified value
--
-- This function may be used in the definition of a 'Show' instance for a
-- @newtype@ representation of a C enumeration.
--
-- When the value is declared, a corresponding name is returned.  Otherwise,
-- a string consisting of the constructor name and the integral value separated
-- by a space is returned.  Examples for a hypothetical enumeration type:
--
-- > showName "StatusCode" StatusOK == "StatusOK"
--
-- > showName "StatusCode" (StatusCode 418) == "StatusCode 418"
showCEnum :: forall a. CEnum a => String -> a -> String
showCEnum constructorName x =
    case Map.lookup i (declaredValues (Proxy :: Proxy a)) of
      Just (name :| _names) -> name
      Nothing -> constructorName ++ ' ' : show (toInteger i)
  where
    i :: CEnumZ a
    i = toCEnumZ x

-- | Determine if the specified value is declared
--
-- This implementation is optimized for 'SequentialCEnum'.
seqIsDeclared :: forall a. SequentialCEnum a => a -> Bool
seqIsDeclared x = i >= minZ && i <= maxZ
  where
    minZ, maxZ, i :: CEnumZ a
    minZ = toCEnumZ (minDeclaredValue @a)
    maxZ = toCEnumZ (maxDeclaredValue @a)
    i    = toCEnumZ x

-- | Construct a value only if it is declared
--
-- This implementation is optimized for 'SequentialCEnum'.
seqMkDeclared :: forall a. SequentialCEnum a => CEnumZ a -> Maybe a
seqMkDeclared i
    | i >= minZ && i <= maxZ = Just (fromCEnumZ i)
    | otherwise = Nothing
  where
    minZ, maxZ :: CEnumZ a
    minZ = toCEnumZ (minDeclaredValue @a)
    maxZ = toCEnumZ (maxDeclaredValue @a)

{-------------------------------------------------------------------------------
  Deriving via support
-------------------------------------------------------------------------------}

-- | Type used to derive classes using @DerivingVia@ a type with a 'CEnum'
-- instance
--
-- When the values are sequential, 'AsSequentialCEnum' provides better
-- performance and should therefore be used instead.
--
-- The following classes may be derived:
--
-- * 'Bounded' may be derived using the bounds of the declared values.  This is
--   /not/ derived by default.
-- * 'Enum` may be derived using the bounds of the declared values.  This
--   instance assumes that only the declared values are valid and throws a
--   'CEnumException' if passed a value that is not declared.  This is /not/
--   derived by default.
newtype AsCEnum a = AsCEnum a

instance CEnum a => Bounded (AsCEnum a) where
  minBound = AsCEnum minBoundGen
  maxBound = AsCEnum maxBoundGen

instance CEnum a => Enum (AsCEnum a) where
  succ (AsCEnum x)                     = AsCEnum $ succGen x
  pred (AsCEnum y)                     = AsCEnum $ predGen y
  toEnum                               = AsCEnum . toEnumGen
  fromEnum (AsCEnum x)                 = fromEnumGen x
  enumFrom (AsCEnum x)                 = AsCEnum <$> enumFromGen x
  enumFromThen (AsCEnum x) (AsCEnum y) = AsCEnum <$> enumFromThenGen x y
  enumFromTo (AsCEnum x) (AsCEnum z)   = AsCEnum <$> enumFromToGen x z
  enumFromThenTo (AsCEnum x) (AsCEnum y) (AsCEnum z) =
    AsCEnum <$> enumFromThenToGen x y z

-- | Type used to derive classes using @DerivingVia@ a type with a
-- 'SequentialCEnum' instance
--
-- The following classes may be derived:
--
-- * 'Bounded' may be derived using the bounds of the declared values.  This is
--   /not/ derived by default.
-- * 'Enum` may be derived using the bounds of the declared values.  This
--   instance assumes that only the declared values are valid and throws a
--   'CEnumException' if passed a value that is not declared.  This is /not/
--   derived by default.
newtype AsSequentialCEnum a = AsSequentialCEnum a

instance SequentialCEnum a => Bounded (AsSequentialCEnum a) where
  minBound = AsSequentialCEnum minBoundSeq
  maxBound = AsSequentialCEnum maxBoundSeq

instance SequentialCEnum a => Enum (AsSequentialCEnum a) where
  succ (AsSequentialCEnum x)     = AsSequentialCEnum $ succSeq x
  pred (AsSequentialCEnum y)     = AsSequentialCEnum $ predSeq y
  toEnum                         = AsSequentialCEnum . toEnumSeq
  fromEnum (AsSequentialCEnum x) = fromEnumSeq x
  enumFrom (AsSequentialCEnum x) = AsSequentialCEnum <$> enumFromSeq x
  enumFromThen (AsSequentialCEnum x) (AsSequentialCEnum y) =
    AsSequentialCEnum <$> enumFromThenSeq x y
  enumFromTo (AsSequentialCEnum x) (AsSequentialCEnum z) =
    AsSequentialCEnum <$> enumFromToSeq x z
  enumFromThenTo
    (AsSequentialCEnum x)
    (AsSequentialCEnum y)
    (AsSequentialCEnum z) =
      AsSequentialCEnum <$> enumFromThenToSeq x y z

{-------------------------------------------------------------------------------
  Exceptions
-------------------------------------------------------------------------------}

-- Exceptions used by optional C enumeration instances
data CEnumException
  = CEnumNotDeclared Integer
  | CEnumNoSuccessor Integer
  | CEnumNoPredecessor Integer
  | CEnumEmpty
  | CEnumFromEqThen Integer
  deriving (Eq, Show)

instance Exception CEnumException where
  displayException = \case
    CEnumNotDeclared i -> "C enumeration value not declared: " ++ show i
    CEnumNoSuccessor i ->
      "C enumeration value has no declared successor: " ++ show i
    CEnumNoPredecessor i ->
      "C enumeration value has no declared predecessor: " ++ show i
    CEnumEmpty -> "C enumeration has no declared values"
    CEnumFromEqThen i -> "enumeration from and then values equal: " ++ show i

{-------------------------------------------------------------------------------
  Bounded instance implementation
-------------------------------------------------------------------------------}

minBoundGen :: forall a. CEnum a => a
minBoundGen = case Map.lookupMin (declaredValues (Proxy :: Proxy a)) of
    Just (i, _names) -> fromCEnumZ i
    Nothing -> throw CEnumEmpty

minBoundSeq :: SequentialCEnum a => a
minBoundSeq = minDeclaredValue

maxBoundGen :: forall a. CEnum a => a
maxBoundGen = case Map.lookupMax (declaredValues (Proxy :: Proxy a)) of
    Just (k, _names) -> fromCEnumZ k
    Nothing -> throw CEnumEmpty

maxBoundSeq :: SequentialCEnum a => a
maxBoundSeq = maxDeclaredValue

{-------------------------------------------------------------------------------
  Enum instance implementation
-------------------------------------------------------------------------------}

succGen :: forall a. CEnum a => a -> a
succGen x = either (throw . CEnumNotDeclared) id $ do
    (_ltMap, gtMap) <- splitMap i (declaredValues (Proxy :: Proxy a))
    case Map.lookupMin gtMap of
      Just (j, _names) -> return $ fromCEnumZ j
      Nothing -> throw $ CEnumNoSuccessor (toInteger i)
  where
    i :: CEnumZ a
    i = toCEnumZ x

succSeq :: forall a. SequentialCEnum a => a -> a
succSeq x
    | i >= minZ && i < maxZ = fromCEnumZ (i + 1)
    | i == maxZ = throw $ CEnumNoSuccessor (toInteger i)
    | otherwise = throw $ CEnumNotDeclared (toInteger i)
  where
    minZ, maxZ, i :: CEnumZ a
    minZ = toCEnumZ (minDeclaredValue @a)
    maxZ = toCEnumZ (maxDeclaredValue @a)
    i    = toCEnumZ x

predGen :: forall a. CEnum a => a -> a
predGen y = either (throw . CEnumNotDeclared) id $ do
    (ltMap, _gtMap) <- splitMap j (declaredValues (Proxy :: Proxy a))
    case Map.lookupMax ltMap of
      Just (i, _names) -> return $ fromCEnumZ i
      Nothing -> throw $ CEnumNoPredecessor (toInteger j)
  where
    j :: CEnumZ a
    j = toCEnumZ y

predSeq :: forall a. SequentialCEnum a => a -> a
predSeq y
    | j > minZ && j <= maxZ = fromCEnumZ (j - 1)
    | j == minZ = throw $ CEnumNoPredecessor (toInteger j)
    | otherwise = throw $ CEnumNotDeclared (toInteger j)
  where
    minZ, maxZ, j :: CEnumZ a
    minZ = toCEnumZ (minDeclaredValue @a)
    maxZ = toCEnumZ (maxDeclaredValue @a)
    j    = toCEnumZ y

toEnumGen :: CEnum a => Int -> a
toEnumGen i = case mkDeclared (fromIntegral i) of
    Just x  -> x
    Nothing -> throw $ CEnumNotDeclared (toInteger i)

toEnumSeq :: forall a. SequentialCEnum a => Int -> a
toEnumSeq n
    | i >= minZ && i <= maxZ = fromCEnumZ i
    | otherwise = throw $ CEnumNotDeclared (toInteger i)
  where
    minZ, maxZ, i :: CEnumZ a
    minZ = toCEnumZ (minDeclaredValue @a)
    maxZ = toCEnumZ (maxDeclaredValue @a)
    i    = fromIntegral n

fromEnumGen :: forall a. CEnum a => a -> Int
fromEnumGen x
    | i `Map.member` declaredValues (Proxy :: Proxy a) = fromIntegral i
    | otherwise = throw $ CEnumNotDeclared (toInteger i)
  where
    i :: CEnumZ a
    i = toCEnumZ x

fromEnumSeq :: forall a. SequentialCEnum a => a -> Int
fromEnumSeq x
    | i >= minZ && i <= maxZ = fromIntegral i
    | otherwise = throw $ CEnumNotDeclared (toInteger i)
  where
    minZ, maxZ, i :: CEnumZ a
    minZ = toCEnumZ (minDeclaredValue @a)
    maxZ = toCEnumZ (maxDeclaredValue @a)
    i    = toCEnumZ x

enumFromGen :: forall a. CEnum a => a -> [a]
enumFromGen x = either (throw . CEnumNotDeclared) id $ do
    (_ltMap, gtMap) <- splitMap i (declaredValues (Proxy :: Proxy a))
    return $ x : map fromCEnumZ (Map.keys gtMap)
  where
    i :: CEnumZ a
    i = toCEnumZ x

enumFromSeq :: forall a. SequentialCEnum a => a -> [a]
enumFromSeq x
    | i >= minZ && i <= maxZ = map fromCEnumZ [i .. maxZ]
    | otherwise = throw $ CEnumNotDeclared (toInteger i)
  where
    minZ, maxZ, i :: CEnumZ a
    minZ = toCEnumZ (minDeclaredValue @a)
    maxZ = toCEnumZ (maxDeclaredValue @a)
    i    = toCEnumZ x

enumFromThenGen :: forall a. CEnum a => a -> a -> [a]
enumFromThenGen x y = case compare i j of
    LT -> either (throw . CEnumNotDeclared) id $ do
      (_ltIMap, gtIMap) <- splitMap i (declaredValues (Proxy :: Proxy a))
      (ltJMap,  gtJMap) <- splitMap j gtIMap
      let w  = Map.size ltJMap + 1
          js = j : Map.keys gtJMap
      return $ x : map (fromCEnumZ . NonEmpty.head) (nonEmptyChunksOf w js)
    GT -> either (throw . CEnumNotDeclared) id $ do
      (ltIMap, _gtIMap) <- splitMap i (declaredValues (Proxy :: Proxy a))
      (ltJMap, gtJMap)  <- splitMap j ltIMap
      let w  = Map.size gtJMap + 1
          js = j : reverse (Map.keys ltJMap)
      return $ x : map (fromCEnumZ . NonEmpty.head) (nonEmptyChunksOf w js)
    EQ -> throw $ CEnumFromEqThen (toInteger i)
  where
    i, j :: CEnumZ a
    i = toCEnumZ x
    j = toCEnumZ y

enumFromThenSeq :: forall a. SequentialCEnum a => a -> a -> [a]
enumFromThenSeq x y
    | i == j = throw $ CEnumFromEqThen (toInteger i)
    | i < minZ || i > maxZ = throw $ CEnumNotDeclared (toInteger i)
    | j < minZ || j > maxZ = throw $ CEnumNotDeclared (toInteger j)
    | i < j = map fromCEnumZ [i, j .. maxZ]
    | otherwise = map fromCEnumZ [i, j .. minZ]
  where
    minZ, maxZ, i, j :: CEnumZ a
    minZ = toCEnumZ (minDeclaredValue @a)
    maxZ = toCEnumZ (maxDeclaredValue @a)
    i    = toCEnumZ x
    j    = toCEnumZ y

enumFromToGen :: forall a. CEnum a => a -> a -> [a]
enumFromToGen x z = either (throw . CEnumNotDeclared) id $ do
    (_ltIMap, gtIMap)  <- splitMap i (declaredValues (Proxy :: Proxy a))
    if i == k
      then return [x]
      else do
        (ltKMap,  _gtKMap) <- splitMap k gtIMap
        return $ x : map fromCEnumZ (Map.keys ltKMap) ++ [z]
  where
    i, k :: CEnumZ a
    i = toCEnumZ x
    k = toCEnumZ z

enumFromToSeq :: forall a. SequentialCEnum a => a -> a -> [a]
enumFromToSeq x z
    | i < minZ || i > maxZ = throw $ CEnumNotDeclared (toInteger i)
    | k < minZ || k > maxZ = throw $ CEnumNotDeclared (toInteger k)
    | otherwise = map fromCEnumZ [i .. k]
  where
    minZ, maxZ, i, k :: CEnumZ a
    minZ = toCEnumZ (minDeclaredValue @a)
    maxZ = toCEnumZ (maxDeclaredValue @a)
    i    = toCEnumZ x
    k    = toCEnumZ z

enumFromThenToGen :: forall a. CEnum a => a -> a -> a -> [a]
enumFromThenToGen x y z = case compare i j of
    LT -> either (throw . CEnumNotDeclared) id $ do
      (_ltIMap, gtIMap)  <- splitMap i (declaredValues (Proxy :: Proxy a))
      (ltJMap,  gtJMap)  <- splitMap j gtIMap
      (ltKMap,  _gtKMap) <- splitMap k gtJMap
      let w  = Map.size ltJMap + 1
          js = j : Map.keys ltKMap ++ [k]
      return $ x : map (fromCEnumZ . NonEmpty.head) (nonEmptyChunksOf w js)
    GT -> either (throw . CEnumNotDeclared) id $ do
      (ltIMap,  _gtIMap) <- splitMap i (declaredValues (Proxy :: Proxy a))
      (ltJMap,  gtJMap)  <- splitMap j ltIMap
      (_ltKMap, gtKMap)  <- splitMap k ltJMap
      let w  = Map.size gtJMap + 1
          js = j : reverse (k : Map.keys gtKMap)
      return $ x : map (fromCEnumZ . NonEmpty.head) (nonEmptyChunksOf w js)
    EQ -> throw $ CEnumFromEqThen (toInteger i)
  where
    i, j, k :: CEnumZ a
    i = toCEnumZ x
    j = toCEnumZ y
    k = toCEnumZ z

enumFromThenToSeq :: forall a. SequentialCEnum a => a -> a -> a -> [a]
enumFromThenToSeq x y z
    | i == j = throw $ CEnumFromEqThen (toInteger i)
    | i < minZ || i > maxZ = throw $ CEnumNotDeclared (toInteger i)
    | j < minZ || j > maxZ = throw $ CEnumNotDeclared (toInteger j)
    | k < minZ || k > maxZ = throw $ CEnumNotDeclared (toInteger k)
    | otherwise = map fromCEnumZ [i, j .. k]
  where
    minZ, maxZ, i, j, k :: CEnumZ a
    minZ = toCEnumZ (minDeclaredValue @a)
    maxZ = toCEnumZ (maxDeclaredValue @a)
    i    = toCEnumZ x
    j    = toCEnumZ y
    k    = toCEnumZ z

{-------------------------------------------------------------------------------
  Auxiliary Functions
-------------------------------------------------------------------------------}

nonEmptyChunksOf :: Int -> [a] -> [NonEmpty a]
nonEmptyChunksOf n xs
    | n > 0     = aux xs
    | otherwise = error $ "nonEmptyChunksOf: n must be positive, got " ++ show n
  where
    aux :: [a] -> [NonEmpty a]
    aux xs' = case first NonEmpty.nonEmpty (List.splitAt n xs') of
      (Just ne, rest)  -> ne : aux rest
      (Nothing, _rest) -> []

splitMap :: Integral k => k -> Map k v -> Either Integer (Map k v, Map k v)
splitMap n m = case Map.splitLookup n m of
    (ltMap,  Just{},  gtMap)  -> Right (ltMap, gtMap)
    (_ltMap, Nothing, _gtMap) -> Left (toInteger n)
