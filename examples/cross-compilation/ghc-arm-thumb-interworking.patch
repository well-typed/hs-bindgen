Fix Thumb interworking for dlsym-resolved symbols on ARM

On ARM, when the runtime linker resolves a symbol via dlsym (e.g. for
symbols imported from shared libraries like glibc), the ELF symbol type
in the loaded object file is typically STT_NOTYPE (undefined/imported).
The existing code only checks the Thumb bit (bit 0) for STT_FUNC
symbols, causing it to miss Thumb functions resolved via dlsym.

This results in the runtime linker generating ARM BL instructions
instead of BLX for calls to Thumb functions like strlen, causing
SIGILL (Illegal instruction) when the CPU tries to execute Thumb-2
code in ARM mode.

The fix adds a fallback: if the ELF symbol type is not STT_FUNC but
bit 0 of the resolved address is set (indicating a Thumb function,
as preserved by dlsym on ARM), treat it as a Thumb target.

Upstream: https://gitlab.haskell.org/ghc/ghc/-/issues/21991

--- a/rts/linker/Elf.c
+++ b/rts/linker/Elf.c
@@ -1263,6 +1263,16 @@
                is_target_thm = S & 0x1;
                T = is_target_thm;
                S &= ~1;
+           } else if(S & 0x1) {
+               /* Symbol resolved via dlsym or with unknown ELF type
+                * (e.g. STT_NOTYPE for imported/undefined symbols).
+                * On ARM, dlsym preserves the Thumb bit (bit 0) for
+                * Thumb functions.  Detect it from the address itself
+                * so that we generate BLX (not BL) for ARM->Thumb calls.
+                */
+               is_target_thm = 1;
+               T = 1;
+               S &= ~1;
            }
 #endif
        }
