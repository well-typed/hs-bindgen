newtype First = First {un_First :: CUInt}
instance Storable First
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure First <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {First un_First_3 -> pokeByteOff ptr_1 (0 :: Int) un_First_3}}
deriving stock instance Eq First
deriving stock instance Ord First
deriving stock instance Read First
instance CEnum First
    where {type CEnumZ First = CUInt;
           wrap = First;
           unwrap = un_First;
           declaredValueMap = \_ -> fromList [(0, pure "FIRST1"),
                                              (1, pure "FIRST2")];
           sequentialValueBounds = \_ -> Just (0, 1)}
instance Show First
    where {show = showCEnum "First"}
pattern FIRST1 :: First
pattern FIRST1 = First 0
pattern FIRST2 :: First
pattern FIRST2 = First 1
newtype Second = Second {un_Second :: CInt}
instance Storable Second
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure Second <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {Second un_Second_3 -> pokeByteOff ptr_1 (0 :: Int) un_Second_3}}
deriving stock instance Eq Second
deriving stock instance Ord Second
deriving stock instance Read Second
instance CEnum Second
    where {type CEnumZ Second = CInt;
           wrap = Second;
           unwrap = un_Second;
           declaredValueMap = \_ -> fromList [(-1, pure "SECOND_A"),
                                              (0, pure "SECOND_B"),
                                              (1, pure "SECOND_C")];
           sequentialValueBounds = \_ -> Just (-1, 1)}
instance Show Second
    where {show = showCEnum "Second"}
pattern SECOND_A :: Second
pattern SECOND_A = Second (-1)
pattern SECOND_B :: Second
pattern SECOND_B = Second 0
pattern SECOND_C :: Second
pattern SECOND_C = Second 1
newtype Same = Same {un_Same :: CUInt}
instance Storable Same
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure Same <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {Same un_Same_3 -> pokeByteOff ptr_1 (0 :: Int) un_Same_3}}
deriving stock instance Eq Same
deriving stock instance Ord Same
deriving stock instance Read Same
instance CEnum Same
    where {type CEnumZ Same = CUInt;
           wrap = Same;
           unwrap = un_Same;
           declaredValueMap = \_ -> fromList [(1, "SAME_B" :| ["SAME_A"])];
           sequentialValueBounds = \_ -> Just (1, 1)}
instance Show Same
    where {show = showCEnum "Same"}
pattern SAME_A :: Same
pattern SAME_A = Same 1
pattern SAME_B :: Same
pattern SAME_B = Same 1
newtype Nonseq = Nonseq {un_Nonseq :: CUInt}
instance Storable Nonseq
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure Nonseq <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {Nonseq un_Nonseq_3 -> pokeByteOff ptr_1 (0 :: Int) un_Nonseq_3}}
deriving stock instance Eq Nonseq
deriving stock instance Ord Nonseq
deriving stock instance Read Nonseq
instance CEnum Nonseq
    where {type CEnumZ Nonseq = CUInt;
           wrap = Nonseq;
           unwrap = un_Nonseq;
           declaredValueMap = \_ -> fromList [(200, pure "NONSEQ_A"),
                                              (301, pure "NONSEQ_B"),
                                              (404, pure "NONSEQ_C")];
           sequentialValueBounds = \_ -> Nothing}
instance Show Nonseq
    where {show = showCEnum "Nonseq"}
pattern NONSEQ_A :: Nonseq
pattern NONSEQ_A = Nonseq 200
pattern NONSEQ_B :: Nonseq
pattern NONSEQ_B = Nonseq 301
pattern NONSEQ_C :: Nonseq
pattern NONSEQ_C = Nonseq 404
newtype Packad = Packad {un_Packad :: CSChar}
instance Storable Packad
    where {sizeOf = \_ -> 1 :: Int;
           alignment = \_ -> 1 :: Int;
           peek = \ptr_0 -> pure Packad <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {Packad un_Packad_3 -> pokeByteOff ptr_1 (0 :: Int) un_Packad_3}}
deriving stock instance Eq Packad
deriving stock instance Ord Packad
deriving stock instance Read Packad
instance CEnum Packad
    where {type CEnumZ Packad = CSChar;
           wrap = Packad;
           unwrap = un_Packad;
           declaredValueMap = \_ -> fromList [(0, pure "PACKED_A"),
                                              (1, pure "PACKED_B"),
                                              (2, pure "PACKED_C")];
           sequentialValueBounds = \_ -> Just (0, 2)}
instance Show Packad
    where {show = showCEnum "Packad"}
pattern PACKED_A :: Packad
pattern PACKED_A = Packad 0
pattern PACKED_B :: Packad
pattern PACKED_B = Packad 1
pattern PACKED_C :: Packad
pattern PACKED_C = Packad 2
newtype EnumA = EnumA {un_EnumA :: CUInt}
instance Storable EnumA
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure EnumA <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {EnumA un_EnumA_3 -> pokeByteOff ptr_1 (0 :: Int) un_EnumA_3}}
deriving stock instance Eq EnumA
deriving stock instance Ord EnumA
deriving stock instance Read EnumA
instance CEnum EnumA
    where {type CEnumZ EnumA = CUInt;
           wrap = EnumA;
           unwrap = un_EnumA;
           declaredValueMap = \_ -> fromList [(0, pure "A_FOO"),
                                              (1, pure "A_BAR")];
           sequentialValueBounds = \_ -> Just (0, 1)}
instance Show EnumA
    where {show = showCEnum "EnumA"}
pattern A_FOO :: EnumA
pattern A_FOO = EnumA 0
pattern A_BAR :: EnumA
pattern A_BAR = EnumA 1
newtype EnumB = EnumB {un_EnumB :: CUInt}
instance Storable EnumB
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure EnumB <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {EnumB un_EnumB_3 -> pokeByteOff ptr_1 (0 :: Int) un_EnumB_3}}
deriving stock instance Eq EnumB
deriving stock instance Ord EnumB
deriving stock instance Read EnumB
instance CEnum EnumB
    where {type CEnumZ EnumB = CUInt;
           wrap = EnumB;
           unwrap = un_EnumB;
           declaredValueMap = \_ -> fromList [(0, pure "B_FOO"),
                                              (1, pure "B_BAR")];
           sequentialValueBounds = \_ -> Just (0, 1)}
instance Show EnumB
    where {show = showCEnum "EnumB"}
pattern B_FOO :: EnumB
pattern B_FOO = EnumB 0
pattern B_BAR :: EnumB
pattern B_BAR = EnumB 1
newtype EnumC = EnumC {un_EnumC :: CUInt}
instance Storable EnumC
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure EnumC <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {EnumC un_EnumC_3 -> pokeByteOff ptr_1 (0 :: Int) un_EnumC_3}}
deriving stock instance Eq EnumC
deriving stock instance Ord EnumC
deriving stock instance Read EnumC
instance CEnum EnumC
    where {type CEnumZ EnumC = CUInt;
           wrap = EnumC;
           unwrap = un_EnumC;
           declaredValueMap = \_ -> fromList [(0, pure "C_FOO"),
                                              (1, pure "C_BAR")];
           sequentialValueBounds = \_ -> Just (0, 1)}
instance Show EnumC
    where {show = showCEnum "EnumC"}
pattern C_FOO :: EnumC
pattern C_FOO = EnumC 0
pattern C_BAR :: EnumC
pattern C_BAR = EnumC 1
newtype EnumD = EnumD {un_EnumD :: CUInt}
instance Storable EnumD
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure EnumD <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {EnumD un_EnumD_3 -> pokeByteOff ptr_1 (0 :: Int) un_EnumD_3}}
deriving stock instance Eq EnumD
deriving stock instance Ord EnumD
deriving stock instance Read EnumD
instance CEnum EnumD
    where {type CEnumZ EnumD = CUInt;
           wrap = EnumD;
           unwrap = un_EnumD;
           declaredValueMap = \_ -> fromList [(0, pure "D_FOO"),
                                              (1, pure "D_BAR")];
           sequentialValueBounds = \_ -> Just (0, 1)}
instance Show EnumD
    where {show = showCEnum "EnumD"}
pattern D_FOO :: EnumD
pattern D_FOO = EnumD 0
pattern D_BAR :: EnumD
pattern D_BAR = EnumD 1
newtype EnumD_t = EnumD_t {un_EnumD_t :: EnumD}
deriving newtype instance Storable EnumD_t
