newtype First = First {un_First :: CUInt}
instance Storable First
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure First <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {First un_First_3 -> pokeByteOff ptr_1 (0 :: Int) un_First_3}}
deriving stock instance Show First
deriving stock instance Read First
deriving stock instance Eq First
deriving stock instance Ord First
instance SequentialCEnum First
    where {type SequentialCEnumZ First = CUInt;
           toSequentialCEnum = First;
           fromSequentialCEnum = un_First;
           sequentialCEnumMin = \_ -> 0;
           sequentialCEnumMax = \_ -> 1}
deriving via (SeqCEnum First) instance Bounded First
deriving via (SeqCEnum First) instance Enum First
pattern FIRST1 :: First
pattern FIRST1 = First 0
pattern FIRST2 :: First
pattern FIRST2 = First 1
newtype Second = Second {un_Second :: CInt}
instance Storable Second
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure Second <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {Second un_Second_3 -> pokeByteOff ptr_1 (0 :: Int) un_Second_3}}
deriving stock instance Show Second
deriving stock instance Read Second
deriving stock instance Eq Second
deriving stock instance Ord Second
instance SequentialCEnum Second
    where {type SequentialCEnumZ Second = CInt;
           toSequentialCEnum = Second;
           fromSequentialCEnum = un_Second;
           sequentialCEnumMin = \_ -> -1;
           sequentialCEnumMax = \_ -> 1}
deriving via (SeqCEnum Second) instance Bounded Second
deriving via (SeqCEnum Second) instance Enum Second
pattern SECOND_A :: Second
pattern SECOND_A = Second (-1)
pattern SECOND_B :: Second
pattern SECOND_B = Second 0
pattern SECOND_C :: Second
pattern SECOND_C = Second 1
newtype Same = Same {un_Same :: CUInt}
instance Storable Same
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure Same <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {Same un_Same_3 -> pokeByteOff ptr_1 (0 :: Int) un_Same_3}}
deriving stock instance Show Same
deriving stock instance Read Same
deriving stock instance Eq Same
deriving stock instance Ord Same
instance SequentialCEnum Same
    where {type SequentialCEnumZ Same = CUInt;
           toSequentialCEnum = Same;
           fromSequentialCEnum = un_Same;
           sequentialCEnumMin = \_ -> 1;
           sequentialCEnumMax = \_ -> 1}
deriving via (SeqCEnum Same) instance Bounded Same
deriving via (SeqCEnum Same) instance Enum Same
pattern SAME_A :: Same
pattern SAME_A = Same 1
pattern SAME_B :: Same
pattern SAME_B = Same 1
newtype Nonseq = Nonseq {un_Nonseq :: CUInt}
instance Storable Nonseq
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure Nonseq <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {Nonseq un_Nonseq_3 -> pokeByteOff ptr_1 (0 :: Int) un_Nonseq_3}}
deriving stock instance Show Nonseq
deriving stock instance Read Nonseq
deriving stock instance Eq Nonseq
deriving stock instance Ord Nonseq
instance GeneralCEnum Nonseq
    where {type GeneralCEnumZ Nonseq = CUInt;
           toGeneralCEnum = Nonseq;
           fromGeneralCEnum = un_Nonseq;
           generalCEnumValues = \_ -> [200, 301, 404]}
deriving via (GenCEnum Nonseq) instance Bounded Nonseq
deriving via (GenCEnum Nonseq) instance Enum Nonseq
pattern NONSEQ_A :: Nonseq
pattern NONSEQ_A = Nonseq 200
pattern NONSEQ_B :: Nonseq
pattern NONSEQ_B = Nonseq 301
pattern NONSEQ_C :: Nonseq
pattern NONSEQ_C = Nonseq 404
newtype Packad = Packad {un_Packad :: CSChar}
instance Storable Packad
    where {sizeOf = \_ -> 1 :: Int;
           alignment = \_ -> 1 :: Int;
           peek = \ptr_0 -> pure Packad <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {Packad un_Packad_3 -> pokeByteOff ptr_1 (0 :: Int) un_Packad_3}}
deriving stock instance Show Packad
deriving stock instance Read Packad
deriving stock instance Eq Packad
deriving stock instance Ord Packad
instance SequentialCEnum Packad
    where {type SequentialCEnumZ Packad = CSChar;
           toSequentialCEnum = Packad;
           fromSequentialCEnum = un_Packad;
           sequentialCEnumMin = \_ -> 0;
           sequentialCEnumMax = \_ -> 2}
deriving via (SeqCEnum Packad) instance Bounded Packad
deriving via (SeqCEnum Packad) instance Enum Packad
pattern PACKED_A :: Packad
pattern PACKED_A = Packad 0
pattern PACKED_B :: Packad
pattern PACKED_B = Packad 1
pattern PACKED_C :: Packad
pattern PACKED_C = Packad 2
newtype EnumA = EnumA {un_EnumA :: CUInt}
instance Storable EnumA
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure EnumA <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {EnumA un_EnumA_3 -> pokeByteOff ptr_1 (0 :: Int) un_EnumA_3}}
deriving stock instance Show EnumA
deriving stock instance Read EnumA
deriving stock instance Eq EnumA
deriving stock instance Ord EnumA
instance SequentialCEnum EnumA
    where {type SequentialCEnumZ EnumA = CUInt;
           toSequentialCEnum = EnumA;
           fromSequentialCEnum = un_EnumA;
           sequentialCEnumMin = \_ -> 0;
           sequentialCEnumMax = \_ -> 1}
deriving via (SeqCEnum EnumA) instance Bounded EnumA
deriving via (SeqCEnum EnumA) instance Enum EnumA
pattern A_FOO :: EnumA
pattern A_FOO = EnumA 0
pattern A_BAR :: EnumA
pattern A_BAR = EnumA 1
newtype EnumB = EnumB {un_EnumB :: CUInt}
instance Storable EnumB
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure EnumB <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {EnumB un_EnumB_3 -> pokeByteOff ptr_1 (0 :: Int) un_EnumB_3}}
deriving stock instance Show EnumB
deriving stock instance Read EnumB
deriving stock instance Eq EnumB
deriving stock instance Ord EnumB
instance SequentialCEnum EnumB
    where {type SequentialCEnumZ EnumB = CUInt;
           toSequentialCEnum = EnumB;
           fromSequentialCEnum = un_EnumB;
           sequentialCEnumMin = \_ -> 0;
           sequentialCEnumMax = \_ -> 1}
deriving via (SeqCEnum EnumB) instance Bounded EnumB
deriving via (SeqCEnum EnumB) instance Enum EnumB
pattern B_FOO :: EnumB
pattern B_FOO = EnumB 0
pattern B_BAR :: EnumB
pattern B_BAR = EnumB 1
newtype EnumC = EnumC {un_EnumC :: CUInt}
instance Storable EnumC
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure EnumC <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {EnumC un_EnumC_3 -> pokeByteOff ptr_1 (0 :: Int) un_EnumC_3}}
deriving stock instance Show EnumC
deriving stock instance Read EnumC
deriving stock instance Eq EnumC
deriving stock instance Ord EnumC
instance SequentialCEnum EnumC
    where {type SequentialCEnumZ EnumC = CUInt;
           toSequentialCEnum = EnumC;
           fromSequentialCEnum = un_EnumC;
           sequentialCEnumMin = \_ -> 0;
           sequentialCEnumMax = \_ -> 1}
deriving via (SeqCEnum EnumC) instance Bounded EnumC
deriving via (SeqCEnum EnumC) instance Enum EnumC
pattern C_FOO :: EnumC
pattern C_FOO = EnumC 0
pattern C_BAR :: EnumC
pattern C_BAR = EnumC 1
newtype EnumD = EnumD {un_EnumD :: CUInt}
instance Storable EnumD
    where {sizeOf = \_ -> 4 :: Int;
           alignment = \_ -> 4 :: Int;
           peek = \ptr_0 -> pure EnumD <*> peekByteOff ptr_0 (0 :: Int);
           poke = \ptr_1 -> \s_2 -> case s_2 of
                                    {EnumD un_EnumD_3 -> pokeByteOff ptr_1 (0 :: Int) un_EnumD_3}}
deriving stock instance Show EnumD
deriving stock instance Read EnumD
deriving stock instance Eq EnumD
deriving stock instance Ord EnumD
instance SequentialCEnum EnumD
    where {type SequentialCEnumZ EnumD = CUInt;
           toSequentialCEnum = EnumD;
           fromSequentialCEnum = un_EnumD;
           sequentialCEnumMin = \_ -> 0;
           sequentialCEnumMax = \_ -> 1}
deriving via (SeqCEnum EnumD) instance Bounded EnumD
deriving via (SeqCEnum EnumD) instance Enum EnumD
pattern D_FOO :: EnumD
pattern D_FOO = EnumD 0
pattern D_BAR :: EnumD
pattern D_BAR = EnumD 1
newtype EnumD_t = EnumD_t {un_EnumD_t :: EnumD}
deriving newtype instance Storable EnumD_t
