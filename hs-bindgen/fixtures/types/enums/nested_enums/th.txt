-- addDependentFile examples/golden/types/enums/nested_enums.h
{-| __C declaration:__ @enum enumA@

    __defined at:__ @types\/enums\/nested_enums.h 2:14@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
newtype EnumA
    = EnumA {unwrapEnumA :: CUInt}
      {- ^ __C declaration:__ @enum enumA@

           __defined at:__ @types\/enums\/nested_enums.h 2:14@

           __exported by:__ @types\/enums\/nested_enums.h@
      -}
    deriving stock (Eq, Ord)
    deriving newtype HasFFIType
instance Storable EnumA
    where sizeOf = \_ -> 4 :: Int
          alignment = \_ -> 4 :: Int
          peek = \ptr_0 -> pure EnumA <*> peekByteOff ptr_0 (0 :: Int)
          poke = \ptr_1 -> \s_2 -> case s_2 of
                                   EnumA unwrapEnumA_3 -> pokeByteOff ptr_1 (0 :: Int) unwrapEnumA_3
deriving via CUInt instance Prim EnumA
instance CEnum EnumA
    where type CEnumZ EnumA = CUInt
          toCEnum = EnumA
          fromCEnum = unwrapEnumA
          declaredValues = \_ -> declaredValuesFromList [(0,
                                                          singleton "VALA_1"),
                                                         (1, singleton "VALA_2")]
          showsUndeclared = showsWrappedUndeclared "EnumA"
          readPrecUndeclared = readPrecWrappedUndeclared "EnumA"
          isDeclared = seqIsDeclared
          mkDeclared = seqMkDeclared
instance SequentialCEnum EnumA
    where minDeclaredValue = VALA_1
          maxDeclaredValue = VALA_2
instance Show EnumA
    where showsPrec = shows
instance Read EnumA
    where readPrec = readPrec
          readList = readListDefault
          readListPrec = readListPrecDefault
{-| __C declaration:__ @VALA_1@

    __defined at:__ @types\/enums\/nested_enums.h 3:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALA_1 :: EnumA
{-| __C declaration:__ @VALA_1@

    __defined at:__ @types\/enums\/nested_enums.h 3:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALA_1 = EnumA 0
{-| __C declaration:__ @VALA_2@

    __defined at:__ @types\/enums\/nested_enums.h 4:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALA_2 :: EnumA
{-| __C declaration:__ @VALA_2@

    __defined at:__ @types\/enums\/nested_enums.h 4:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALA_2 = EnumA 1
{-| __C declaration:__ @struct exA@

    __defined at:__ @types\/enums\/nested_enums.h 1:8@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
data ExA
    = ExA {exA_fieldA1 :: EnumA
           {- ^ __C declaration:__ @fieldA1@

                __defined at:__ @types\/enums\/nested_enums.h 5:11@

                __exported by:__ @types\/enums\/nested_enums.h@
           -}}
      {- ^ __C declaration:__ @struct exA@

           __defined at:__ @types\/enums\/nested_enums.h 1:8@

           __exported by:__ @types\/enums\/nested_enums.h@
      -}
    deriving stock (Eq, Show)
instance Storable ExA
    where sizeOf = \_ -> 4 :: Int
          alignment = \_ -> 4 :: Int
          peek = \ptr_0 -> pure ExA <*> peek (Proxy @"exA_fieldA1") ptr_0
          poke = \ptr_1 -> \s_2 -> case s_2 of
                                   ExA exA_fieldA1_3 -> poke (Proxy @"exA_fieldA1") ptr_1 exA_fieldA1_3
instance HasCField ExA "exA_fieldA1"
    where type CFieldType ExA "exA_fieldA1" = EnumA
          offset# = \_ -> \_ -> 0
instance TyEq ty (CFieldType ExA "exA_fieldA1") =>
         HasField "exA_fieldA1" (Ptr ExA) (Ptr ty)
    where getField = fromPtr (Proxy @"exA_fieldA1")
{-| __C declaration:__ @enum \@exB_fieldB1@

    __defined at:__ @types\/enums\/nested_enums.h 9:9@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
newtype ExB_fieldB1
    = ExB_fieldB1 {unwrapExB_fieldB1 :: CUInt}
      {- ^ __C declaration:__ @enum \@exB_fieldB1@

           __defined at:__ @types\/enums\/nested_enums.h 9:9@

           __exported by:__ @types\/enums\/nested_enums.h@
      -}
    deriving stock (Eq, Ord)
    deriving newtype HasFFIType
instance Storable ExB_fieldB1
    where sizeOf = \_ -> 4 :: Int
          alignment = \_ -> 4 :: Int
          peek = \ptr_0 -> pure ExB_fieldB1 <*> peekByteOff ptr_0 (0 :: Int)
          poke = \ptr_1 -> \s_2 -> case s_2 of
                                   ExB_fieldB1 unwrapExB_fieldB1_3 -> pokeByteOff ptr_1 (0 :: Int) unwrapExB_fieldB1_3
deriving via CUInt instance Prim ExB_fieldB1
instance CEnum ExB_fieldB1
    where type CEnumZ ExB_fieldB1 = CUInt
          toCEnum = ExB_fieldB1
          fromCEnum = unwrapExB_fieldB1
          declaredValues = \_ -> declaredValuesFromList [(0,
                                                          singleton "VALB_1"),
                                                         (1, singleton "VALB_2")]
          showsUndeclared = showsWrappedUndeclared "ExB_fieldB1"
          readPrecUndeclared = readPrecWrappedUndeclared "ExB_fieldB1"
          isDeclared = seqIsDeclared
          mkDeclared = seqMkDeclared
instance SequentialCEnum ExB_fieldB1
    where minDeclaredValue = VALB_1
          maxDeclaredValue = VALB_2
instance Show ExB_fieldB1
    where showsPrec = shows
instance Read ExB_fieldB1
    where readPrec = readPrec
          readList = readListDefault
          readListPrec = readListPrecDefault
{-| __C declaration:__ @VALB_1@

    __defined at:__ @types\/enums\/nested_enums.h 10:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALB_1 :: ExB_fieldB1
{-| __C declaration:__ @VALB_1@

    __defined at:__ @types\/enums\/nested_enums.h 10:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALB_1 = ExB_fieldB1 0
{-| __C declaration:__ @VALB_2@

    __defined at:__ @types\/enums\/nested_enums.h 11:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALB_2 :: ExB_fieldB1
{-| __C declaration:__ @VALB_2@

    __defined at:__ @types\/enums\/nested_enums.h 11:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALB_2 = ExB_fieldB1 1
{-| __C declaration:__ @struct exB@

    __defined at:__ @types\/enums\/nested_enums.h 8:8@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
data ExB
    = ExB {exB_fieldB1 :: ExB_fieldB1
           {- ^ __C declaration:__ @fieldB1@

                __defined at:__ @types\/enums\/nested_enums.h 12:11@

                __exported by:__ @types\/enums\/nested_enums.h@
           -}}
      {- ^ __C declaration:__ @struct exB@

           __defined at:__ @types\/enums\/nested_enums.h 8:8@

           __exported by:__ @types\/enums\/nested_enums.h@
      -}
    deriving stock (Eq, Show)
instance Storable ExB
    where sizeOf = \_ -> 4 :: Int
          alignment = \_ -> 4 :: Int
          peek = \ptr_0 -> pure ExB <*> peek (Proxy @"exB_fieldB1") ptr_0
          poke = \ptr_1 -> \s_2 -> case s_2 of
                                   ExB exB_fieldB1_3 -> poke (Proxy @"exB_fieldB1") ptr_1 exB_fieldB1_3
instance HasCField ExB "exB_fieldB1"
    where type CFieldType ExB "exB_fieldB1" = ExB_fieldB1
          offset# = \_ -> \_ -> 0
instance TyEq ty (CFieldType ExB "exB_fieldB1") =>
         HasField "exB_fieldB1" (Ptr ExB) (Ptr ty)
    where getField = fromPtr (Proxy @"exB_fieldB1")
