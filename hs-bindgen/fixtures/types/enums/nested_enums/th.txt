-- addDependentFile examples/golden/types/enums/nested_enums.h
{-| __C declaration:__ @enum enumA@

    __defined at:__ @types\/enums\/nested_enums.h 2:14@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
newtype EnumA
    = EnumA {unwrapEnumA :: CUInt}
      {- ^ __C declaration:__ @enum enumA@

           __defined at:__ @types\/enums\/nested_enums.h 2:14@

           __exported by:__ @types\/enums\/nested_enums.h@
      -}
    deriving stock (Eq, Generic, Ord)
    deriving newtype HasFFIType
instance StaticSize EnumA
    where staticSizeOf = \_ -> 4 :: Int
          staticAlignment = \_ -> 4 :: Int
instance ReadRaw EnumA
    where readRaw = \ptr_0 -> pure EnumA <*> readRawByteOff ptr_0 (0 :: Int)
instance WriteRaw EnumA
    where writeRaw = \ptr_0 -> \s_1 -> case s_1 of
                                       EnumA unwrapEnumA_2 -> writeRawByteOff ptr_0 (0 :: Int) unwrapEnumA_2
deriving via (EquivStorable EnumA) instance Storable EnumA
deriving via CUInt instance Prim EnumA
instance CEnum EnumA
    where type CEnumZ EnumA = CUInt
          toCEnum = EnumA
          fromCEnum = unwrapEnumA
          declaredValues = \_ -> declaredValuesFromList [(0,
                                                          singleton "VALA_1"),
                                                         (1, singleton "VALA_2")]
          showsUndeclared = showsWrappedUndeclared "EnumA"
          readPrecUndeclared = readPrecWrappedUndeclared "EnumA"
          isDeclared = seqIsDeclared
          mkDeclared = seqMkDeclared
instance SequentialCEnum EnumA
    where minDeclaredValue = VALA_1
          maxDeclaredValue = VALA_2
instance Show EnumA
    where showsPrec = shows
instance Read EnumA
    where readPrec = readPrec
          readList = readListDefault
          readListPrec = readListPrecDefault
instance (~) ty CUInt =>
         HasField "unwrapEnumA" (Ptr EnumA) (Ptr ty)
    where getField = fromPtr (Proxy @"unwrapEnumA")
instance HasCField EnumA "unwrapEnumA"
    where type CFieldType EnumA "unwrapEnumA" = CUInt
          offset# = \_ -> \_ -> 0
{-| __C declaration:__ @VALA_1@

    __defined at:__ @types\/enums\/nested_enums.h 3:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALA_1 :: EnumA
{-| __C declaration:__ @VALA_1@

    __defined at:__ @types\/enums\/nested_enums.h 3:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALA_1 = EnumA 0
{-| __C declaration:__ @VALA_2@

    __defined at:__ @types\/enums\/nested_enums.h 4:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALA_2 :: EnumA
{-| __C declaration:__ @VALA_2@

    __defined at:__ @types\/enums\/nested_enums.h 4:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALA_2 = EnumA 1
{-| __C declaration:__ @struct exA@

    __defined at:__ @types\/enums\/nested_enums.h 1:8@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
data ExA
    = ExA {exA_fieldA1 :: EnumA
           {- ^ __C declaration:__ @fieldA1@

                __defined at:__ @types\/enums\/nested_enums.h 5:11@

                __exported by:__ @types\/enums\/nested_enums.h@
           -}}
      {- ^ __C declaration:__ @struct exA@

           __defined at:__ @types\/enums\/nested_enums.h 1:8@

           __exported by:__ @types\/enums\/nested_enums.h@
      -}
    deriving stock (Eq, Generic, Show)
instance StaticSize ExA
    where staticSizeOf = \_ -> 4 :: Int
          staticAlignment = \_ -> 4 :: Int
instance ReadRaw ExA
    where readRaw = \ptr_0 -> pure ExA <*> readRaw (Proxy @"exA_fieldA1") ptr_0
instance WriteRaw ExA
    where writeRaw = \ptr_0 -> \s_1 -> case s_1 of
                                       ExA exA_fieldA1_2 -> writeRaw (Proxy @"exA_fieldA1") ptr_0 exA_fieldA1_2
deriving via (EquivStorable ExA) instance Storable ExA
instance HasCField ExA "exA_fieldA1"
    where type CFieldType ExA "exA_fieldA1" = EnumA
          offset# = \_ -> \_ -> 0
instance (~) ty EnumA => HasField "exA_fieldA1" (Ptr ExA) (Ptr ty)
    where getField = fromPtr (Proxy @"exA_fieldA1")
{-| __C declaration:__ @enum \@exB_fieldB1@

    __defined at:__ @types\/enums\/nested_enums.h 9:9@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
newtype ExB_fieldB1
    = ExB_fieldB1 {unwrapExB_fieldB1 :: CUInt}
      {- ^ __C declaration:__ @enum \@exB_fieldB1@

           __defined at:__ @types\/enums\/nested_enums.h 9:9@

           __exported by:__ @types\/enums\/nested_enums.h@
      -}
    deriving stock (Eq, Generic, Ord)
    deriving newtype HasFFIType
instance StaticSize ExB_fieldB1
    where staticSizeOf = \_ -> 4 :: Int
          staticAlignment = \_ -> 4 :: Int
instance ReadRaw ExB_fieldB1
    where readRaw = \ptr_0 -> pure ExB_fieldB1 <*> readRawByteOff ptr_0 (0 :: Int)
instance WriteRaw ExB_fieldB1
    where writeRaw = \ptr_0 -> \s_1 -> case s_1 of
                                       ExB_fieldB1 unwrapExB_fieldB1_2 -> writeRawByteOff ptr_0 (0 :: Int) unwrapExB_fieldB1_2
deriving via (EquivStorable ExB_fieldB1) instance Storable ExB_fieldB1
deriving via CUInt instance Prim ExB_fieldB1
instance CEnum ExB_fieldB1
    where type CEnumZ ExB_fieldB1 = CUInt
          toCEnum = ExB_fieldB1
          fromCEnum = unwrapExB_fieldB1
          declaredValues = \_ -> declaredValuesFromList [(0,
                                                          singleton "VALB_1"),
                                                         (1, singleton "VALB_2")]
          showsUndeclared = showsWrappedUndeclared "ExB_fieldB1"
          readPrecUndeclared = readPrecWrappedUndeclared "ExB_fieldB1"
          isDeclared = seqIsDeclared
          mkDeclared = seqMkDeclared
instance SequentialCEnum ExB_fieldB1
    where minDeclaredValue = VALB_1
          maxDeclaredValue = VALB_2
instance Show ExB_fieldB1
    where showsPrec = shows
instance Read ExB_fieldB1
    where readPrec = readPrec
          readList = readListDefault
          readListPrec = readListPrecDefault
instance (~) ty CUInt =>
         HasField "unwrapExB_fieldB1" (Ptr ExB_fieldB1) (Ptr ty)
    where getField = fromPtr (Proxy @"unwrapExB_fieldB1")
instance HasCField ExB_fieldB1 "unwrapExB_fieldB1"
    where type CFieldType ExB_fieldB1 "unwrapExB_fieldB1" = CUInt
          offset# = \_ -> \_ -> 0
{-| __C declaration:__ @VALB_1@

    __defined at:__ @types\/enums\/nested_enums.h 10:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALB_1 :: ExB_fieldB1
{-| __C declaration:__ @VALB_1@

    __defined at:__ @types\/enums\/nested_enums.h 10:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALB_1 = ExB_fieldB1 0
{-| __C declaration:__ @VALB_2@

    __defined at:__ @types\/enums\/nested_enums.h 11:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALB_2 :: ExB_fieldB1
{-| __C declaration:__ @VALB_2@

    __defined at:__ @types\/enums\/nested_enums.h 11:17@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
pattern VALB_2 = ExB_fieldB1 1
{-| __C declaration:__ @struct exB@

    __defined at:__ @types\/enums\/nested_enums.h 8:8@

    __exported by:__ @types\/enums\/nested_enums.h@
-}
data ExB
    = ExB {exB_fieldB1 :: ExB_fieldB1
           {- ^ __C declaration:__ @fieldB1@

                __defined at:__ @types\/enums\/nested_enums.h 12:11@

                __exported by:__ @types\/enums\/nested_enums.h@
           -}}
      {- ^ __C declaration:__ @struct exB@

           __defined at:__ @types\/enums\/nested_enums.h 8:8@

           __exported by:__ @types\/enums\/nested_enums.h@
      -}
    deriving stock (Eq, Generic, Show)
instance StaticSize ExB
    where staticSizeOf = \_ -> 4 :: Int
          staticAlignment = \_ -> 4 :: Int
instance ReadRaw ExB
    where readRaw = \ptr_0 -> pure ExB <*> readRaw (Proxy @"exB_fieldB1") ptr_0
instance WriteRaw ExB
    where writeRaw = \ptr_0 -> \s_1 -> case s_1 of
                                       ExB exB_fieldB1_2 -> writeRaw (Proxy @"exB_fieldB1") ptr_0 exB_fieldB1_2
deriving via (EquivStorable ExB) instance Storable ExB
instance HasCField ExB "exB_fieldB1"
    where type CFieldType ExB "exB_fieldB1" = ExB_fieldB1
          offset# = \_ -> \_ -> 0
instance (~) ty ExB_fieldB1 =>
         HasField "exB_fieldB1" (Ptr ExB) (Ptr ty)
    where getField = fromPtr (Proxy @"exB_fieldB1")
