-- addDependentFile examples/golden/types/nested_enums.h
{-| __C declaration:__ @enumA@

    __defined at:__ @types\/nested_enums.h:2:14@

    __exported by:__ @types\/nested_enums.h@
-}
newtype EnumA
    = EnumA {un_EnumA :: CUInt}
      {- ^ __C declaration:__ @enumA@

           __defined at:__ @types\/nested_enums.h:2:14@

           __exported by:__ @types\/nested_enums.h@
      -}
    deriving stock (Eq, Ord)
instance Storable EnumA
    where sizeOf = \_ -> 4 :: Int
          alignment = \_ -> 4 :: Int
          peek = \ptr_0 -> pure EnumA <*> peekByteOff ptr_0 (0 :: Int)
          poke = \ptr_1 -> \s_2 -> case s_2 of
                                   EnumA un_EnumA_3 -> pokeByteOff ptr_1 (0 :: Int) un_EnumA_3
instance CEnum EnumA
    where type CEnumZ EnumA = CUInt
          toCEnum = EnumA
          fromCEnum = un_EnumA
          declaredValues = \_ -> declaredValuesFromList [(0,
                                                          singleton "VALA_1"),
                                                         (1, singleton "VALA_2")]
          showsUndeclared = showsWrappedUndeclared "EnumA"
          readPrecUndeclared = readPrecWrappedUndeclared "EnumA"
          isDeclared = seqIsDeclared
          mkDeclared = seqMkDeclared
instance SequentialCEnum EnumA
    where minDeclaredValue = VALA_1
          maxDeclaredValue = VALA_2
instance Show EnumA
    where showsPrec = showsCEnum
instance Read EnumA
    where readPrec = readPrecCEnum
          readList = readListDefault
          readListPrec = readListPrecDefault
{-| __C declaration:__ @VALA_1@

    __defined at:__ @types\/nested_enums.h:3:17@

    __exported by:__ @types\/nested_enums.h@
-}
pattern VALA_1 :: EnumA
{-| __C declaration:__ @VALA_1@

    __defined at:__ @types\/nested_enums.h:3:17@

    __exported by:__ @types\/nested_enums.h@
-}
pattern VALA_1 = EnumA 0
{-| __C declaration:__ @VALA_2@

    __defined at:__ @types\/nested_enums.h:4:17@

    __exported by:__ @types\/nested_enums.h@
-}
pattern VALA_2 :: EnumA
{-| __C declaration:__ @VALA_2@

    __defined at:__ @types\/nested_enums.h:4:17@

    __exported by:__ @types\/nested_enums.h@
-}
pattern VALA_2 = EnumA 1
{-| __C declaration:__ @exA@

    __defined at:__ @types\/nested_enums.h:1:8@

    __exported by:__ @types\/nested_enums.h@
-}
data ExA
    = ExA {exA_fieldA1 :: EnumA
           {- ^ __C declaration:__ @fieldA1@

                __defined at:__ @types\/nested_enums.h:5:11@

                __exported by:__ @types\/nested_enums.h@
           -}}
      {- ^ __C declaration:__ @exA@

           __defined at:__ @types\/nested_enums.h:1:8@

           __exported by:__ @types\/nested_enums.h@
      -}
    deriving stock (Eq, Show)
instance Storable ExA
    where sizeOf = \_ -> 4 :: Int
          alignment = \_ -> 4 :: Int
          peek = \ptr_0 -> pure ExA <*> peekCField (Proxy @"exA_fieldA1") ptr_0
          poke = \ptr_1 -> \s_2 -> case s_2 of
                                   ExA exA_fieldA1_3 -> pokeCField (Proxy @"exA_fieldA1") ptr_1 exA_fieldA1_3
instance HasCField ExA "exA_fieldA1"
    where type CFieldType ExA "exA_fieldA1" = EnumA
          offset# = \_ -> \_ -> 0
instance TyEq ty (CFieldType ExA "exA_fieldA1") =>
         HasField "exA_fieldA1" (Ptr ExA) (Ptr ty)
    where getField = ptrToCField (Proxy @"exA_fieldA1")
{-| __defined at:__ @types\/nested_enums.h:9:9@

    __exported by:__ @types\/nested_enums.h@
-}
newtype ExB_fieldB1
    = ExB_fieldB1 {un_ExB_fieldB1 :: CUInt}
      {- ^ __defined at:__ @types\/nested_enums.h:9:9@

           __exported by:__ @types\/nested_enums.h@
      -}
    deriving stock (Eq, Ord)
instance Storable ExB_fieldB1
    where sizeOf = \_ -> 4 :: Int
          alignment = \_ -> 4 :: Int
          peek = \ptr_0 -> pure ExB_fieldB1 <*> peekByteOff ptr_0 (0 :: Int)
          poke = \ptr_1 -> \s_2 -> case s_2 of
                                   ExB_fieldB1 un_ExB_fieldB1_3 -> pokeByteOff ptr_1 (0 :: Int) un_ExB_fieldB1_3
instance CEnum ExB_fieldB1
    where type CEnumZ ExB_fieldB1 = CUInt
          toCEnum = ExB_fieldB1
          fromCEnum = un_ExB_fieldB1
          declaredValues = \_ -> declaredValuesFromList [(0,
                                                          singleton "VALB_1"),
                                                         (1, singleton "VALB_2")]
          showsUndeclared = showsWrappedUndeclared "ExB_fieldB1"
          readPrecUndeclared = readPrecWrappedUndeclared "ExB_fieldB1"
          isDeclared = seqIsDeclared
          mkDeclared = seqMkDeclared
instance SequentialCEnum ExB_fieldB1
    where minDeclaredValue = VALB_1
          maxDeclaredValue = VALB_2
instance Show ExB_fieldB1
    where showsPrec = showsCEnum
instance Read ExB_fieldB1
    where readPrec = readPrecCEnum
          readList = readListDefault
          readListPrec = readListPrecDefault
{-| __C declaration:__ @VALB_1@

    __defined at:__ @types\/nested_enums.h:10:17@

    __exported by:__ @types\/nested_enums.h@
-}
pattern VALB_1 :: ExB_fieldB1
{-| __C declaration:__ @VALB_1@

    __defined at:__ @types\/nested_enums.h:10:17@

    __exported by:__ @types\/nested_enums.h@
-}
pattern VALB_1 = ExB_fieldB1 0
{-| __C declaration:__ @VALB_2@

    __defined at:__ @types\/nested_enums.h:11:17@

    __exported by:__ @types\/nested_enums.h@
-}
pattern VALB_2 :: ExB_fieldB1
{-| __C declaration:__ @VALB_2@

    __defined at:__ @types\/nested_enums.h:11:17@

    __exported by:__ @types\/nested_enums.h@
-}
pattern VALB_2 = ExB_fieldB1 1
{-| __C declaration:__ @exB@

    __defined at:__ @types\/nested_enums.h:8:8@

    __exported by:__ @types\/nested_enums.h@
-}
data ExB
    = ExB {exB_fieldB1 :: ExB_fieldB1
           {- ^ __C declaration:__ @fieldB1@

                __defined at:__ @types\/nested_enums.h:12:11@

                __exported by:__ @types\/nested_enums.h@
           -}}
      {- ^ __C declaration:__ @exB@

           __defined at:__ @types\/nested_enums.h:8:8@

           __exported by:__ @types\/nested_enums.h@
      -}
    deriving stock (Eq, Show)
instance Storable ExB
    where sizeOf = \_ -> 4 :: Int
          alignment = \_ -> 4 :: Int
          peek = \ptr_0 -> pure ExB <*> peekCField (Proxy @"exB_fieldB1") ptr_0
          poke = \ptr_1 -> \s_2 -> case s_2 of
                                   ExB exB_fieldB1_3 -> pokeCField (Proxy @"exB_fieldB1") ptr_1 exB_fieldB1_3
instance HasCField ExB "exB_fieldB1"
    where type CFieldType ExB "exB_fieldB1" = ExB_fieldB1
          offset# = \_ -> \_ -> 0
instance TyEq ty (CFieldType ExB "exB_fieldB1") =>
         HasField "exB_fieldB1" (Ptr ExB) (Ptr ty)
    where getField = ptrToCField (Proxy @"exB_fieldB1")
