/* this header is autogenerated with cabal run hs-bindgen-bootstrap */
/* Type information for CXCursors https://clang.llvm.org/doxygen/group__CINDEX__TYPES.html */

static inline void wrap_getCursorType(const CXCursor* C, CXType* result) {
  *result = clang_getCursorType(*C);
}

static inline void wrap_getTypeSpelling(const CXType* CT, CXString* result) {
  *result = clang_getTypeSpelling(*CT);
}

static inline void wrap_getTypedefDeclUnderlyingType(const CXCursor* C, CXType* result) {
  *result = clang_getTypedefDeclUnderlyingType(*C);
}

static inline void wrap_getEnumDeclIntegerType(const CXCursor* C, CXType* result) {
  *result = clang_getEnumDeclIntegerType(*C);
}

static inline long long wrap_getEnumConstantDeclValue(const CXCursor* C) {
  return clang_getEnumConstantDeclValue(*C);
}

static inline unsigned long long wrap_getEnumConstantDeclUnsignedValue(const CXCursor* C) {
  return clang_getEnumConstantDeclUnsignedValue(*C);
}

static inline unsigned wrap_Cursor_isBitField(const CXCursor* C) {
  return clang_Cursor_isBitField(*C);
}

static inline int wrap_getFieldDeclBitWidth(const CXCursor* C) {
  return clang_getFieldDeclBitWidth(*C);
}

static inline int wrap_Cursor_getNumArguments(const CXCursor* C) {
  return clang_Cursor_getNumArguments(*C);
}

static inline void wrap_Cursor_getArgument(const CXCursor* C, unsigned i, CXCursor* result) {
  *result = clang_Cursor_getArgument(*C, i);
}

/* int clang_Cursor_getNumTemplateArguments (CXCursor C); // C++ */

/* enum CXTemplateArgumentKind clang_Cursor_getTemplateArgumentKind (CXCursor C, unsigned I); // C++ */

/* CXType clang_Cursor_getTemplateArgumentType (CXCursor C, unsigned I); // C++ */

/* long long clang_Cursor_getTemplateArgumentValue (CXCursor C, unsigned I); // C++ */

/* unsigned long long clang_Cursor_getTemplateArgumentUnsignedValue (CXCursor C, unsigned I); // C++ */

static inline unsigned wrap_equalTypes(const CXType* A, const CXType* B) {
  return clang_equalTypes(*A, *B);
}

static inline void wrap_getCanonicalType(const CXType* T, CXType* result) {
  *result = clang_getCanonicalType(*T);
}

static inline unsigned wrap_isConstQualifiedType(const CXType* T) {
  return clang_isConstQualifiedType(*T);
}

static inline unsigned wrap_Cursor_isMacroFunctionLike(const CXCursor* C) {
  return clang_Cursor_isMacroFunctionLike(*C);
}

static inline unsigned wrap_Cursor_isMacroBuiltin(const CXCursor* C) {
  return clang_Cursor_isMacroBuiltin(*C);
}

static inline unsigned wrap_Cursor_isFunctionInlined(const CXCursor* C) {
  return clang_Cursor_isFunctionInlined(*C);
}

static inline unsigned wrap_isVolatileQualifiedType(const CXType* T) {
  return clang_isVolatileQualifiedType(*T);
}

static inline unsigned wrap_isRestrictQualifiedType(const CXType* T) {
  return clang_isRestrictQualifiedType(*T);
}

static inline unsigned wrap_getAddressSpace(const CXType* T) {
  return clang_getAddressSpace(*T);
}

static inline void wrap_getTypedefName(const CXType* CT, CXString* result) {
  *result = clang_getTypedefName(*CT);
}

static inline void wrap_getPointeeType(const CXType* T, CXType* result) {
  *result = clang_getPointeeType(*T);
}

/* CXType clang_getUnqualifiedType (CXType CT); // this is special case */

/* CXType clang_getNonReferenceType (CXType CT); // this is apparently special case as well (not available in older libclang) */

static inline void wrap_getTypeDeclaration(const CXType* T, CXCursor* result) {
  *result = clang_getTypeDeclaration(*T);
}

/* CXString clang_getDeclObjCTypeEncoding (CXCursor C); // Objective C */

/* CXString clang_Type_getObjCEncoding (CXType type); // Objective C */

static inline void wrap_getTypeKindSpelling(enum CXTypeKind K, CXString* result) {
  *result = clang_getTypeKindSpelling(K);
}

/* enum CXCallingConv clang_getFunctionTypeCallingConv (CXType T); // no enum */

static inline void wrap_getResultType(const CXType* T, CXType* result) {
  *result = clang_getResultType(*T);
}

/* int clang_getExceptionSpecificationType (CXType T); // C++ */

static inline int wrap_getNumArgTypes(const CXType* T) {
  return clang_getNumArgTypes(*T);
}

static inline void wrap_getArgType(const CXType* T, unsigned i, CXType* result) {
  *result = clang_getArgType(*T, i);
}

static inline void wrap_Type_getObjCObjectBaseType(const CXType* T, CXType* result) {
  *result = clang_Type_getObjCObjectBaseType(*T);
}

static inline unsigned wrap_Type_getNumObjCProtocolRefs(const CXType* T) {
  return clang_Type_getNumObjCProtocolRefs(*T);
}

static inline void wrap_Type_getObjCProtocolDecl(const CXType* T, unsigned i, CXCursor* result) {
  *result = clang_Type_getObjCProtocolDecl(*T, i);
}

static inline unsigned wrap_Type_getNumObjCTypeArgs(const CXType* T) {
  return clang_Type_getNumObjCTypeArgs(*T);
}

static inline void wrap_Type_getObjCTypeArg(const CXType* T, unsigned i, CXType* result) {
  *result = clang_Type_getObjCTypeArg(*T, i);
}

static inline unsigned wrap_isFunctionTypeVariadic(const CXType* T) {
  return clang_isFunctionTypeVariadic(*T);
}

static inline void wrap_getCursorResultType(const CXCursor* C, CXType* result) {
  *result = clang_getCursorResultType(*C);
}

static inline int wrap_getCursorExceptionSpecificationType(const CXCursor* C) {
  return clang_getCursorExceptionSpecificationType(*C);
}

static inline unsigned wrap_isPODType(const CXType* T) {
  return clang_isPODType(*T);
}

static inline void wrap_getElementType(const CXType* T, CXType* result) {
  *result = clang_getElementType(*T);
}

static inline long long wrap_getNumElements(const CXType* T) {
  return clang_getNumElements(*T);
}

static inline void wrap_getArrayElementType(const CXType* T, CXType* result) {
  *result = clang_getArrayElementType(*T);
}

static inline long long wrap_getArraySize(const CXType* T) {
  return clang_getArraySize(*T);
}

static inline void wrap_Type_getNamedType(const CXType* T, CXType* result) {
  *result = clang_Type_getNamedType(*T);
}

static inline unsigned wrap_Type_isTransparentTagTypedef(const CXType* T) {
  return clang_Type_isTransparentTagTypedef(*T);
}

/* enum CXTypeNullabilityKind clang_Type_getNullability (CXType T); // no enum */

static inline long long wrap_Type_getAlignOf(const CXType* T) {
  return clang_Type_getAlignOf(*T);
}

/* CXType clang_Type_getClassType (CXType T); // C++ */

static inline long long wrap_Type_getSizeOf(const CXType* T) {
  return clang_Type_getSizeOf(*T);
}

/* long long clang_Type_getOffsetOf (CXType T, const char *S) // TODO: generator doesn't know * yet */

static inline void wrap_Type_getModifiedType(const CXType* T, CXType* result) {
  *result = clang_Type_getModifiedType(*T);
}

static inline void wrap_Type_getValueType(const CXType* CT, CXType* result) {
  *result = clang_Type_getValueType(*CT);
}

static inline long long wrap_Cursor_getOffsetOfField(const CXCursor* C) {
  return clang_Cursor_getOffsetOfField(*C);
}

static inline unsigned wrap_Cursor_isAnonymous(const CXCursor* C) {
  return clang_Cursor_isAnonymous(*C);
}

static inline unsigned wrap_Cursor_isAnonymousRecordDecl(const CXCursor* C) {
  return clang_Cursor_isAnonymousRecordDecl(*C);
}

/* unsigned clang_Cursor_isInlineNamespace (CXCursor C); // C++ */

/* int clang_Type_getNumTemplateArguments (CXType T); // C++ */

/* CXType clang_Type_getTemplateArgumentAsType (CXType T, unsigned i); // C++ */

/* enum CXRefQualifierKind clang_Type_getCXXRefQualifier (CXType T); // C++ */

/* unsigned clang_isVirtualBase (CXCursor); // C++ */

/* enum CX_CXXAccessSpecifier clang_getCXXAccessSpecifier (CXCursor); // C++ */

/* enum CX_BinaryOperatorKind clang_Cursor_getBinaryOpcode (CXCursor C); // C++ */

/* CXString clang_Cursor_getBinaryOpcodeStr (enum CX_BinaryOperatorKind Op); // C++ */

/* enum CX_StorageClass clang_Cursor_getStorageClass (CXCursor); // no enum */

/* unsigned clang_getNumOverloadedDecls (CXCursor cursor); // C++ */

/* CXCursor clang_getOverloadedDecl (CXCursor cursor, unsigned index); // C++ */

/* Cursor manipulations https://clang.llvm.org/doxygen/group__CINDEX__CURSOR__MANIP.html */

static inline void wrap_getNullCursor(CXCursor* result) {
  *result = clang_getNullCursor();
}

/* CXCursor clang_getTranslationUnitCursor (CXTranslationUnit unit); CXTranslationUnit is defined in LowLevel.Core */

static inline unsigned wrap_equalCursors(const CXCursor* A, const CXCursor* B) {
  return clang_equalCursors(*A, *B);
}

static inline int wrap_Cursor_isNull(const CXCursor* cursor) {
  return clang_Cursor_isNull(*cursor);
}

static inline unsigned wrap_hashCursor(const CXCursor* cursor) {
  return clang_hashCursor(*cursor);
}

static inline enum CXCursorKind wrap_getCursorKind(const CXCursor* cursor) {
  return clang_getCursorKind(*cursor);
}

static inline unsigned wrap_isInvalidDeclaration(const CXCursor* cursor) {
  return clang_isInvalidDeclaration(*cursor);
}

static inline unsigned wrap_Cursor_hasAttrs(const CXCursor* C) {
  return clang_Cursor_hasAttrs(*C);
}

/* enum CXLinkageKind clang_getCursorLinkage (CXCursor cursor); // no enum */

/* enum CXVisibilityKind clang_getCursorVisibility (CXCursor cursor); // no enum */

/* enum CXAvailabilityKind clang_getCursorAvailability (CXCursor cursor); // no enum */

/* int clang_getCursorPlatformAvailability (CXCursor cursor, int *always_deprecated, CXString *deprecated_message, int *always_unavailable, CXString *unavailable_message, CXPlatformAvailability *availability, int availability_size); */

/* void clang_disposeCXPlatformAvailability (CXPlatformAvailability *availability); */

static inline void wrap_Cursor_getVarDeclInitializer(const CXCursor* cursor, CXCursor* result) {
  *result = clang_Cursor_getVarDeclInitializer(*cursor);
}

static inline int wrap_Cursor_hasVarDeclGlobalStorage(const CXCursor* cursor) {
  return clang_Cursor_hasVarDeclGlobalStorage(*cursor);
}

static inline int wrap_Cursor_hasVarDeclExternalStorage(const CXCursor* cursor) {
  return clang_Cursor_hasVarDeclExternalStorage(*cursor);
}

/* enum CXLanguageKind clang_getCursorLanguage (CXCursor cursor); // no enum */

/* enum CXTLSKind clang_getCursorTLSKind (CXCursor cursor); // no enum */

/* CXTranslationUnit clang_Cursor_getTranslationUnit (CXCursor cursor); CXTranslationUnit is defined in LowLevel.Core */

/* CXCursorSet clang_createCXCursorSet (void); // no cursor set */

/* void clang_disposeCXCursorSet (CXCursorSet cset); // no cursor set */

/* unsigned clang_CXCursorSet_contains (CXCursorSet cset, CXCursor cursor); // no cursor set */

/* unsigned clang_CXCursorSet_insert (CXCursorSet cset, CXCursor cursor); // no cursor set */

static inline void wrap_getCursorSemanticParent(const CXCursor* cursor, CXCursor* result) {
  *result = clang_getCursorSemanticParent(*cursor);
}

static inline void wrap_getCursorLexicalParent(const CXCursor* cursor, CXCursor* result) {
  *result = clang_getCursorLexicalParent(*cursor);
}

/* void clang_getOverriddenCursors (CXCursor cursor, CXCursor **overridden, unsigned *num_overridden); // C++? */

/* void clang_disposeOverriddenCursors (CXCursor *overridden); // C++? */

static inline CXFile wrap_getIncludedFile(const CXCursor* cursor) {
  return clang_getIncludedFile(*cursor);
}

/* File manipulation routines https://clang.llvm.org/doxygen/group__CINDEX__FILES.html */

static inline void wrap_getFileName(CXFile SFile, CXString* result) {
  *result = clang_getFileName(SFile);
}

/* Debugging facilities https://clang.llvm.org/doxygen/group__CINDEX__DEBUG.html */

static inline void wrap_getCursorKindSpelling(enum CXCursorKind Kind, CXString* result) {
  *result = clang_getCursorKindSpelling(Kind);
}

/* void clang_getDefinitionSpellingAndExtent (CXCursor, const char **startBuf, const char **endBuf, unsigned *startLine, unsigned *startColumn, unsigned *endLine, unsigned *endColumn); */

/* void clang_enableStackTraces (void); */

/* void clang_executeOnThread (void(*fn)(void *), void *user_data, unsigned stack_size); */

