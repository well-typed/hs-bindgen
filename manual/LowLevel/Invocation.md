# Invocation

TODO

## Preprocessor

TODO

## Template Haskell

TODO

## Literate Haskell

TODO

## Haskell library

TODO

## Setting up an environment that is able to build and run `hs-bindgen`

Depending on the platform, there are specific steps and considerations to
ensure a smooth experience with `hs-bindgen`. This guide will walk you through
the setup process for Linux, macOS, and Windows, highlighting the nuances of
each operating system.

### Linux

Setting up on Linux, such as Ubuntu, involves making a choice on your
compiler, installing necessary tools like LLVM and Clang, and correctly
configuring your environment variables.

#### Compiler choices (GCC vs. Clang)

GCC is the default compiler on many Linux distributions and is also the compiler
used by GHC. `hs-bindgen` uses `libclang` internally to parse C code.
Differences in how GCC and Clang handle aspects like memory layout can lead to
incorrect bindings. Unfortunately it is not straightforward to make GHC use
Clang without effectively, building GHC from scratch. There are flags like
`-pgmc` and `-pgml` ([see reference
here](https://downloads.haskell.org/ghc/latest/docs/users_guide/phases.html#replacing-the-program-for-one-or-more-phases))
which allow one to tell GHC which C compiler to use, however experiments showed
that just setting these flags was not enough. For more details see the
discussions at issues
[#846](https://github.com/well-typed/hs-bindgen/issues/846), and
[#847](https://github.com/well-typed/hs-bindgen/issues/847).

All in all, using Clang for both your C code and the code generated by `hs-bindgen`
would ensure consistency and correctness, but we currently don't thoroughly
test with `clang`.

#### Installation of LLVM and Clang

You'll need to install LLVM and Clang. The specific package names may vary
slightly depending on your distribution.

#### Adding `cabal.project.local`

Your program might need some extra help figuring out where to find the C source
files and headers. This can be done, amongst other ways, by creating a
`cabal.project.local` file defines `extra-include-dirs` and `extra-lib-dirs`.

For example, in order to build the manual you will need the following:

```
package manual
  extra-include-dirs:
      <path-to-hs-bindgen>/manual/c
  extra-lib-dirs:
      <path-to-hs-bindgen>/manual/c

package hs-game
  extra-include-dirs:
      <path-to-hs-bindgen>/manual/c
  extra-lib-dirs:
      <path-to-hs-bindgen>/manual/c

package hs-vector
  extra-include-dirs:
      <path-to-hs-bindgen>/manual/c
  extra-lib-dirs:
      <path-to-hs-bindgen>/manual/c
```

Note that the example above enables compilation of the manual from this
repository. For a custom project, `extra-include-dirs` and `extra-lib-dirs`
should be set in the `.cabal` file.

#### Setting environment variables

Properly setting environment variables is crucial for `hs-bindgen` to find the necessary tools and libraries in Linux.

  * `LD_LIBRARY_PATH`: To ensure that the C libraries you build can be linked
  at runtime, you need to add their location to this variable.

      * Example: If your shared library `libexample.so` is in `/path/to/your/c/libs`, you would run:
        ```bash
        export LD_LIBRARY_PATH=/path/to/your/c/libs:$LD_LIBRARY_PATH
        ```

  * `BINDGEN_EXTRA_CLANG_ARGS`: This variable allows you to pass extra
  arguments to `libclang`. This is particularly useful for specifying include
  directories.

      * To find your system's default include paths, you can run:
        ```bash
        clang -v -E -xc /dev/null
        ```
      * You can then set the variable with these paths:
        ```bash
        export BINDGEN_EXTRA_CLANG_ARGS="-nostdinc -I/usr/lib/clang/14/include -I/usr/include"
        ```

        **NOTE**: Without `--no-stdinc`, there are likely multiple directories
        in the C include path that provide the same headers. Which header is
        ultimately used depends on the order of directories in the include
        path.

      * Note that the common use of this environment variable is to set
        preprocessor flags. So only overwrite the include paths if absolutely
        necessary.

  * `LLVM_PATH`, `LLVM_CONFIG`: `hs-bindgen` may need to know where to find
  your LLVM installation.

  ```bash
  export LLVM_PATH=/usr/lib/llvm-14
  export LLVM_CONFIG=$LLVM_PATH/bin/llvm-config
  ```

  This is only needed when you want to use a version of LLVM/Clang that is
  not in your current `PATH`.

#### Common Errors and Solutions

  * Missing headers (`stddef.h`, etc.): If you encounter errors about missing
  standard headers, it's a sign that `libclang` cannot find the system's
  include directories. Setting `BINDGEN_EXTRA_CLANG_ARGS` as described above
  is the solution.

  * Missing shared libraries (`libexample.so`): If you see an error like
  `cannot open shared object file: No such file or directory`, it means the
  dynamic linker can't find your C library. Adding the library's directory to
  `LD_LIBRARY_PATH` or making sure your cabal.project.local points to the
  right folder will resolve this.

  * Unicode character issues with LLVM backend: When using the LLVM backend,
  you might encounter issues with Unicode characters in your C code. This can
  sometimes manifest as errors at the assembler level. Ensure your source
  files do not include Unicode.

### MacOS

On macOS, the setup is similar to Linux, but with its own specific environment
variables and considerations, especially concerning the system's default Clang
installation. Note that Apple's assembler does not support Unicode so make
sure to avoid using Unicode-specific characters in C function definitions.

#### Environment Variables

  * `DYLD_LIBRARY_PATH`: This is the macOS equivalent of `LD_LIBRARY_PATH`. It
  tells the dynamic linker where to find dynamic libraries (`.dylib` files).

      * Example:
        ```bash
        export DYLD_LIBRARY_PATH=/path/to/your/c/libs:$DYLD_LIBRARY_PATH
        ```

  * `BINDGEN_EXTRA_CLANG_ARGS`: On MacOS, setting the include paths like we
  suggest to do in Linux is not required. If you need to, see the section for
  Linux on how to set it up.

### Windows

Setting up on Windows has its own set of unique challenges, particularly
around how Dynamic-Link Libraries (DLLs) are handled and the configuration of
the compiler environment.

#### Built-in Clang with GHC installation

When you install GHC on Windows using GHCup, for example, it comes with a MinGW
environment that includes LLVM and Clang. Note that Windows' assembler does not
support Unicode so make sure to avoid using Unicode-specific characters in C
function definitions.

#### Explicit handling of `PATH` for DLLs

On Windows, the primary way the system finds DLLs at runtime is by searching
the directories listed in the `PATH` environment variable. This is a crucial
difference from Linux and MacOS.

  * To ensure your application can find its required DLLs, add the corresponding
    directories to the `PATH`:
    ```powershell
    $env:PATH = "C:\path\to\your\c\libs;" + $env:PATH
    ```

#### Environment Variables

  * `LLVM_PATH`, `LLVM_CONFIG`, `LIBCLANG_PATH`: You need to point `hs-bindgen`
  to the LLVM/Clang installation that comes with GHC. Make sure these flags
  aren't already set to the right paths.

    ```powershell
    $env:LLVM_PATH = "C:\ghcup\ghc\<your-ghc-version>\mingw"
    $env:LLVM_CONFIG = "$env:LLVM_PATH\bin\llvm-config.exe"
    $env:LIBCLANG_PATH = "$env:LLVM_PATH\lib"
    ```

  * `BINDGEN_EXTRA_CLANG_ARGS`: On Windows, setting the include paths like we
  suggest to do in Linux is not required. If you need to, see the section for
  Linux on how to set it up.

#### Common Errors and Solutions

  * Dynamic-link library loading order: If your application fails silently
  or with an `ExitFailure` and a cryptic error code like `(-1073741515)`, it
  is very likely a DLL loading issue. Adding the directory containing your C
  libraries' DLLs to the system `PATH` is the solution.

  * Resolving issues with underlying type mismatches (`FC.CInt` vs.
  `FC.CUInt`): You might encounter Haskell type errors where, for example, a C
  `int` is being interpreted as a `CUInt` instead of a `CInt`. This is often
  due to how different compilers and platforms define basic types. Carefully
  check your C and Haskell type definitions to ensure they match.

  Bindings generated by `hs-bindgen` are not portable. In order to create a
  portable API, one must do so at a higher level, using CPP to create an
  abstraction layer over the low-level, platform-specific bindings.

  Given that `hs-bindgen` only supports generating bindings for a subset of
  targets people use Hackage with, perhaps all generated bindings uploaded to
  Hackage should include appropriate gates. Minimal example:

  ```
  if !(os(linux) && arch(x86_64))
    buildable: false
  ```
