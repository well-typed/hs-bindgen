# Invocation

TODO

## Preprocessor

TODO

## Template Haskell

TODO

## Literate Haskell

TODO

## Haskell library

TODO

## Environment variables

A small set of environment variables affects the behavior of `hs-bindgen`.

Users can provide extra command-line arguments to `libclang`:

- __When compiling natively (i.e., without specifying a target)__: `hs-bindgen`
  reads
  `BINDGEN_EXTRA_CLANG_ARGS` and splits its string value into command-line
  arguments, respecting shell escapes. For example,

  ```sh
  BINDGEN_EXTRA_CLANG_ARGS="arg1\ with\ whitespace\ endOfArg1 arg2"
  BINDGEN_EXTRA_CLANG_ARGS="\"arg1 with whitespace endOfArg1\" arg2"
  ```

- __When cross-compiling to a given target__: `hs-bindgen` uses
  `BINDGEN_EXTRA_CLANG_ARGS_<TARGET>` instead of `BINDGEN_EXTRA_CLANG_ARGS`.
  Supported `<TARGET>`s: `x86_64-pc-linux`, `i386-pc-linux`, `aarch64-pc-linux`,
  `x86_64-pc-windows`, `x86_64-apple-macosx`, `aarch64-apple-macosx`.
  `hs-bindgen` falls back to `BINDGEN_EXTRA_CLANG_ARGS` if the target-specific
  environment variable is unset or empty. Therefore, a non-empty,
  target-specific variable takes precedence, and `hs-bindgen` ignores
  `BINDGEN_EXTRA_CLANG_ARGS`.

This behavior is consistent with that of
[`rust-bindgen`](https://github.com/rust-lang/rust-bindgen?tab=readme-ov-file#environment-variables).

Configuration of `libclang` via environment variables is important because:

- Software distribution maintainers (e.g., for NixOS) may want to configure
  `hs-bindgen`'s behavior for packages that use it.

- Users may want to configure `hs-bindgen`'s behavior when it is invoked via
  Template Haskell (using `hashInclude`, `hashInclude'` or `hashIncludeWith`),
  without modifying the source code.

Note that when using `hs-bindgen-cli`, users can fully configure `libclang`
with command-line arguments. For instance, they can set:

- `--system-include-path DIR`,
- `--include-path DIR`, and
- `--clang-option OPTION` (for other options passed directly to `libclang`).

## Setting up an Environment that is able to build and run `hs-bindgen`

Depending on the platform, there are specific steps and considerations to
ensure a smooth experience with `hs-bindgen`. This guide will walk you through
the setup process for Linux, macOS, and Windows, highlighting the nuances of
each operating system.

For an example of how to setup the environment for each particular platform
please see:

- [Building and running the manual on Ubuntu](../../.github/workflows/build-manual-ubuntu.yml)
- [Building and running the manual on Ubuntu with LLVM](../../.github/workflows/build-manual-ubuntu-llvm.yml)
- [Building and running the manual on MacOS](../../.github/workflows/build-manual-macos.yml)
- [Building and running the manual on Windows](../../.github/workflows/build-manual-windows.yml)

### Linux

Setting up on Linux, such as Ubuntu, involves making a choice on your
compiler, installing necessary tools like LLVM and Clang, and correctly
configuring your environment variables to avoid common pitfalls.

#### Compiler Choices (GCC vs. Clang)

GCC is the default compiler on many Linux distributions and is also the
compiler used by GHC. `hs-bindgen` uses `libclang` internally to parse C code.
Differences in how GCC and Clang handle aspects like memory layout can lead to
incorrect bindings. Unfortunately it is not straightforward to make GHC use
clang without effectively, building GHC from scratch. There are flags like
`-pgmc` and `-pgml` ([see reference here](https://downloads.haskell.org/ghc/latest/docs/users_guide/phases.html#replacing-the-program-for-one-or-more-phases))
which allow one to tell GHC which C compiler to use, however after some
experimentation proved that just setting these flags was not enough. For more
details see the discussions at issues
[#846](https://github.com/well-typed/hs-bindgen/issues/846)
[#847](https://github.com/well-typed/hs-bindgen/issues/847).

All in all, using Clang for both your C code and the code generated by `hs-bindgen`
would ensure consistency and correctness. But we currently don't thoroughly
test with `clang`.

#### Installation of LLVM and Clang

You'll need to install LLVM and Clang. The specific package names may vary
slightly depending on your distribution.

#### Adding cabal.project.local

You program might need some extra help figuring out where to fetch the C
source files and headers. This can be done, amongst other ways, by creating a
cabal.project.local file that points `extra-include-dirs` and `extra-lib-dirs`
to the right folder.

For example, in order to build the manual you will need the following:

```
package manual
  extra-include-dirs:
      <path-to-hs-bindgen>/manual/c
  extra-lib-dirs:
      <path-to-hs-bindgen>/manual/c

package hs-game
  extra-include-dirs:
      <path-to-hs-bindgen>/manual/c
  extra-lib-dirs:
      <path-to-hs-bindgen>/manual/c

package hs-vector
  extra-include-dirs:
      <path-to-hs-bindgen>/manual/c
  extra-lib-dirs:
      <path-to-hs-bindgen>/manual/c
```

#### Setting Environment Variables

Properly setting environment variables is crucial for `hs-bindgen` to find the necessary tools and libraries in Linux.

  * `LD_LIBRARY_PATH`: To ensure that the C libraries you build can be found
                       at runtime, you need to add their location to this variable.

      * **Example**: If your shared library `libexample.so` is in `/path/to/your/c/libs`, you would run:
        ```bash
        export LD_LIBRARY_PATH=/path/to/your/c/libs:$LD_LIBRARY_PATH
        ```

  * `BINDGEN_EXTRA_CLANG_ARGS`: This variable allows you to pass extra arguments to `libclang`.
                                This is particularly useful for specifying include directories.

      * **To find your system's default include paths**, you can run:
        ```bash
        clang -v -E -xc /dev/null
        ```
      * You can then set the variable with these paths:
        ```bash
        export BINDGEN_EXTRA_CLANG_ARGS="-nostdinc -I/usr/lib/clang/14/include -I/usr/include"
        ```

        **NOTE**: Without `--no-stdinc`, there are likely multiple directories
        in the C include path that provide the same headers.  If different,
        then which header is used is order-dependent, which is not good.

      * In [CI](../../.github/workflows/build-manual-ubuntu.yml) we do a bit
        of parsing to get the results automatically.

      * Note that setting this environment variable this is only needed in
      Linux.

  * `LLVM_PATH`, `LLVM_CONFIG`: `hs-bindgen` may need to know where to find your LLVM installation.

    ```bash
    export LLVM_PATH=/usr/lib/llvm-14
    export LLVM_CONFIG=$LLVM_PATH/bin/llvm-config
    ```

  * `SUPPORTS_UNICODE`: This is only specific to building the manual. The
                        manual has some Unicode Haskell definitions and depending on the platform
                        these are supported or not. Linux supports them so if you want to build and
                        run the manual using these Unicode definitions you should also set this flag
                        and add `-DSUPPORTS_UNICODE` to `BINDGEN_EXTRA_CLANG_ARGS`

#### Common Errors and Solutions

  * Missing headers (`stddef.h`, etc.): If you encounter errors about missing standard headers,
                                        it's a sign that `libclang` cannot find the
                                        system's include directories. Setting `BINDGEN_EXTRA_CLANG_ARGS` as
                                        described above is the solution.

  * Missing shared libraries (`libexample.so`): If you see an error like `cannot open shared object file: No such file or directory`,
                                                it means the dynamic linker can't find your C library. Adding the library's directory
                                                to `LD_LIBRARY_PATH` or making sure your cabal.project.local points to the right folder
                                                will resolve this.

  * Unicode character issues with LLVM backend: When using the LLVM backend, you might encounter issues with Unicode characters in your C
                                                code. This can sometimes manifest as errors at the assembler level. Ensure
                                                your source files do not include Unicode.

### MacOS

On macOS, the setup is similar to Linux, but with its own specific environment
variables and considerations, especially concerning the system's default Clang
installation. Note that Apple's assembler does not support Unicode so make
sure to avoid using it on C function definitions.

#### Environment Variables

  * `DYLD_LIBRARY_PATH`: This is the macOS equivalent of `LD_LIBRARY_PATH`. It
                         tells the dynamic linker where to find dynamic libraries (`.dylib` files).

      * **Example**:
        ```bash
        export DYLD_LIBRARY_PATH=/path/to/your/c/libs:$DYLD_LIBRARY_PATH
        ```

  * `BINDGEN_EXTRA_CLANG_ARGS`: On MacOS setting the include paths like we
                                suggest to do in Linux is not required. If
                                you need to see the section for Linux on how
                                to set it up.

### Windows

Setting up on Windows has its own set of unique challenges, particularly
around how Dynamic-Link Libraries (DLLs) are handled and the configuration of
the compiler environment.

#### Built-in Clang with GHC installation

When you install GHC on Windows using GHCup, for example, it comes with a
MinGW environment that includes LLVM and Clang. Note that Windows' assembler
does not support Unicode so make sure to avoid using it on C function
definitions.

#### Explicit handling of `PATH` for DLLs

On Windows, the primary way the system finds DLLs at runtime is by searching
the directories listed in the `PATH` environment variable. This is a crucial
difference from Linux and macOS.

  * To ensure your application can find its required DLLs, add their directory to the `PATH`:
    ```powershell
    $env:PATH = "C:\path\to\your\c\libs;" + $env:PATH
    ```

#### Environment Variables

  * `LLVM_PATH`, `LLVM_CONFIG`, `LIBCLANG_PATH`: You need to point `hs-bindgen` to the LLVM/Clang installation that comes with GHC.
                                                 Make sure these flags aren't already set to the right paths.

    ```powershell
    $env:LLVM_PATH = "C:\ghcup\ghc\<your-ghc-version>\mingw"
    $env:LLVM_CONFIG = "$env:LLVM_PATH\bin\llvm-config.exe"
    $env:LIBCLANG_PATH = "$env:LLVM_PATH\lib"
    ```

  * `BINDGEN_EXTRA_CLANG_ARGS`: On MacOS setting the include paths like we
                                suggest to do in Linux is not required. If
                                you need to see the section for Linux on how
                                to set it up.

#### Common Errors and Solutions

  * Dynamic-link library loading order: If your application fails silently
                                        or with an `ExitFailure` and a cryptic error code like `(-1073741515)`, it
                                        is very likely a DLL loading issue. Adding the directory containing your C
                                        libraries' DLLs to the system `PATH` is the solution.

  * Resolving issues with underlying type mismatches (`FC.CInt` vs. `FC.CUInt`): You might encounter Haskell type errors where, for example, a
                                                                                 C `int` is being interpreted as a `CUInt` instead of a `CInt`. This is
                                                                                 often due to how different compilers and platforms define basic types.
                                                                                 Carefully check your C and Haskell type definitions to ensure they match.
