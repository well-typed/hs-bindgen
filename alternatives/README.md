# Alternative generators

To better understand the design goals of `hs-bindgen`, it is useful to compare
it to the most common alternatives.

## `hsc2hs`

The bindings are generated by turning the Haskell module into a C program, which
generates the same Haskell module again, but with all `#foo` expressions
replaced with their appropriate values, relying on C compiler features such as
`offsetof` and `sizeof`.

For example,

```haskell
instance Storable HaskellStruct where
  sizeOf    _ = #size      struct ExampleStruct
  alignment _ = #alignment struct ExampleStruct
```

turns into something like

```c
hsc_fputs ("\n"
       "instance Storable HaskellStruct where\n"
       "  sizeOf    _ = ", hsc_stdout());
hsc_size (struct ExampleStruct);
hsc_fputs ("\n", hsc_stdout());
hsc_fputs ("  alignment _ = ", hsc_stdout());
hsc_alignment (struct ExampleStruct);
hsc_fputs ("\n", hsc_stdout());
```

where these `hsc_` functions are declared or defined as macros in
`template-hsc.h`, which is shipped with GHC. The relevant ones in this
example are

```c
#define hsc_size(t...) \
    hsc_printf("(%ld)", (long) sizeof(t));

#define hsc_alignment(x...)                                           \
  do {                                                                \
    struct __anon_x__ {                                               \
      char a;                                                         \
      x b;                                                            \
    };                                                                \
    hsc_printf("%lu", (unsigned long)offsetof(struct __anon_x__, b)); \
  } while (0)
```

Similarly, the expressions

```haskell
(#peek struct ExampleStruct, a)
(#poke struct ExampleStruct, a)
```

turn into

```c
hsc_peek (struct ExampleStruct, a);
hsc_poke (struct ExampleStruct, a);
```

where

```c
#define hsc_peek(t, f) \
    hsc_printf ("(\\hsc_ptr -> peekByteOff hsc_ptr %ld)", \
                (long) offsetof (t, f));

#define hsc_poke(t, f) \
    hsc_printf ("(\\hsc_ptr -> pokeByteOff hsc_ptr %ld)", \
                (long) offsetof (t, f));
```

It also supports writing some inline-C using `#def`, as some form of poor-man's
<https://hackage.haskell.org/package/inline-c>.

You get no support for declaring function signatures, this piggy-backs on the
regular FFI (CAPI or otherwise).

See https://ghc.gitlab.haskell.org/ghc/doc/users_guide/utils.html#writing-haskell-interfaces-to-c-code-hsc2hs for more information.

## `c2hs`

The main point of `c2hs` is to allow users to write _high level_ bindings in
a more convenient manner, by providing for certain types of abstractions.
For example, where with `c2hs` or manual bindings, we end up having to write

```haskell
alloca $ \ptr -> do
  poke ptr $ HaskellStruct 1234 5678
  cShowStruct ptr
```

but with `hsc2hs` we can capture this pattern

```haskell
withAlloca :: Storable a => a -> (Ptr () -> IO r) -> IO r
withAlloca s k =
    alloca $ \ptr -> do
      poke ptr s
      k (castPtr ptr)

{# fun hs_bindgen_c_example_showStruct as cShowStruct
     {withAlloca* `HaskellStruct'} -> `()'
#}
```

at which point we can write

```haskell
cShowStruct $ HaskellStruct 1234 5678
```

However, the syntax for these is rather arcane, and not all common patterns can
be expressed (see https://well-typed.com/blog/2023/03/purgatory/ for some
examples).

The `Storable` story here is similar to the one in `hsc2hs`, albeit with
slightly different syntax. Unlike `hsc2hs`, however, `c2hs` does not use the C
compiler, but does its own calculations; these have been known to be unreliable
at times, especially with cross compilation.

See https://github.com/haskell/c2hs/wiki/User-Guide for more information.

## `cgen`

TODO <https://github.com/well-typed/hs-bindgen/issues/6>

## `fficxx`

TODO <https://github.com/well-typed/hs-bindgen/issues/7>

## Bespoke generators

There are a number of bespoke generators, that don't generate bindings from
Haskell files, but from richer API descriptions. In this section we mention a
few of these; perhaps we can take some inspiration from these API descriptions
in the kind of customization options that `hs-bindgen` should offer.

### https://github.com/gtk2hs/gtk2hs/tree/master/tools/apiGen

> It works by extracting an api description from the C source files and
> extracting documentation from the docbook documentation produced by gtk-doc.

### https://github.com/haskell-gi/haskell-gi

> Generate Haskell bindings for GObject Introspection capable libraries.

This is essential next version of `apiGen`.

### https://github.com/brendanhay/amazonka

> The gen package contain a code generator for synthesising Haskell data types,
> packages, and configuration from the botocore service definitions.

where https://github.com/boto/botocore is

> A low-level interface to a growing number of Amazon Web Services. The botocore
> package is the foundation for the AWS CLI as well as boto3. Botocore is
> maintained and published by Amazon Web Services.

### https://hackage.haskell.org/package/godot-haskell

Generates bindings from the Godot documentation, not from general header files.

### https://github.com/ekmett/gl

> The `gl` package supplies low level bindings to all of the OpenGL
> specification for Haskell. This package, `glgen`, is used to build the `gl`
> package.

Generates bindings from the [Khronos XML specification of
OpenGL](https://registry.khronos.org/OpenGL/).

### https://hackage.haskell.org/package/vulkan

Generates bindings from the Vulkan docs.

The `README`
[goes into some detail](https://github.com/expipiplus1/vulkan?tab=readme-ov-file#how-the-c-types-relate-to-haskell-types)
on the chosen relation between C types and Haskell types.

### https://hackage.haskell.org/package/vulkan-api

Generate bindings from the Vulkan XML spec. Makes some different choices for the
mappings; see discussion in
[Why another Haskell bindings?](https://github.com/achirkin/vulkan?tab=readme-ov-file#why-another-haskell-bindings).
